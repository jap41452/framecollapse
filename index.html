<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Frame Collapse — Incremental Analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:18px; --canvas-w:700px; --canvas-h:560px; --panel-w:680px; }
  body { background:#f6f7fb; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
  h2 { margin:0 0 10px; }
  .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
  .col { background:#fff; border:1px solid #ddd; border-radius:12px; padding:var(--pad); }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  .controls.split { justify-content:flex-start; }
  button, select, input[type="number"], input[type="text"]{
    height:32px; padding:0 10px; border:1px solid #bbb; border-radius:8px; background:#eee; font-size:14px; color:#333;
  }
  input[type="range"]{ width:120px; }
  button { cursor:pointer; transition:background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
  button.primary { background:#eee; color:#333; border-color:#bbb; }
  button.ghost   { background:#eee; color:#333; border-color:#bbb; }
  button.action  { background:#e0f2fe; color:#0369a1; border-color:#7dd3fc; font-weight:600; }
  button.active  { background:#cfd8e3; color:#555; border-color:#9aa6b2; box-shadow: inset 0 0 0 1px #9aa6b2; cursor:default; }

  .labelbtn { pointer-events:none; opacity:1; font-weight:600; }
  .stack { display:flex; flex-direction:column; gap:8px; }
  
  .panel-row { display: flex; gap: 10px; margin-top: 10px; }
  .panel-half { flex: 1; min-width: 0; }

  #wrap { position:relative; width:var(--canvas-w); height:var(--canvas-h); background:#fff; border:1px solid #ccc; border-radius:8px; }
  canvas { position:absolute; inset:0; }
  #base { z-index:1; } #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

  .panel { width:var(--panel-w); }
  .list { font-size:13px; max-height:240px; overflow:auto; border:1px dashed #ddd; padding:8px; border-radius:8px; }
  .hint { color:#666; font-size:12px; }
  .swal2-popup { font-size:12px !important; width:auto !important; min-width:360px !important; }
  .swal2-input, .swal2-select { font-size:12px !important; height:28px !important; }

  .node-row { display:grid; grid-template-columns: 54px 1fr 1fr 28px; gap:6px; align-items:center; }
  .node-row > .badge { justify-self:start; font-weight:600; color:#334155; }
  .node-row input[type="number"]{ width:100%; height:28px; padding:0 6px; border-radius:6px; }
  .node-row button { height:28px; padding:0 8px; }

  #stressPanelBlock { display:none; }
  #stressPanel { width:100%; height:260px; position:static; border:1px solid #ccc; border-radius:8px; }
</style>
</head>

<body>
  <h2>FRAME COLLAPSE (Incremental)</h2>

  <div class="controls split" id="rowTop">
    <button id="btnDraw"   class="primary">Draw Members</button>
    <button id="btnSelect" class="ghost">Select/Edit</button>
    <button id="viewGeom" class="ghost">Geometry</button>
    <button id="btnUndo"  class="ghost">Undo</button>
    <button id="btnClear" class="ghost">Clear</button>
    <span class="hint" style="margin-left:6px;">
      Double-click member to set Yield (Fy) & ShapeF.
    </span>
  </div>

  <div class="row">
    <div class="col">
      <div id="wrap">
        <canvas id="base"    width="700" height="560"></canvas>
        <canvas id="overlay" width="700" height="560"></canvas>
      </div>

      <div class="controls split" style="margin-top:10px; gap:12px;">
        <button class="ghost labelbtn" disabled>Seg Divs</button>
        <input id="divCount"  type="number" min="1" max="50" value="10" style="width:60px;">

        <button id="btnSolve" class="primary">Solve Static</button>
        <button id="btnCollapse" class="action">Run Collapse Analysis</button>

        <div style="width:1px; height:24px; background:#ccc; margin:0 4px;"></div>

        <button id="btnAnimate" class="ghost">Animate</button>
        <button id="viewStressPanel" class="ghost">Stresses</button>

        <button class="ghost labelbtn" disabled>Def Scale</button>
        <input id="defScale"  type="number" step="any" value="1" style="width:60px;">

        <button id="btnResetView" class="ghost">Reset</button>
      </div>
    </div>

    <div class="col panel stack">
      <div>
        <div><strong>Units (display only)</strong></div>
        <div class="controls">
          <button id="btnUS" class="ghost">US (in, lbs, psi)</button>
          <button id="btnSI" class="ghost">SI (m, N, Pa)</button>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong>Nodes</strong>
            <span class="hint">Edit X/Y</span>
          </div>
          <div id="nodeList" class="list"></div>
        </div>

        <div class="panel-half">
          <div><strong>Members</strong></div>
          <div id="memberList" class="list"></div>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div><strong>Analysis Log</strong></div>
          <div id="resultList" class="list"></div>
        </div>

        <div class="panel-half">
          <div id="stressPanelBlock">
            <div class="controls" style="justify-content:space-between; align-items:center;">
              <strong>Stress Panel</strong>
              <div style="display:flex;align-items:center;gap:6px;">
                <label class="ghost labelbtn" disabled>Plot</label>
                <select id="stressPlotMode" style="height:26px;padding:0 6px;">
                  <option value="sigma">σ (top / bottom)</option>
                  <option value="N">N (axial)</option>
                  <option value="M">M (moment)</option>
                </select>
                <button id="btnCloseStressPanel" class="ghost">Close</button>
              </div>
            </div>
            <canvas id="stressPanel"></canvas>
            <div id="stressPanelHint" class="hint" style="margin-top:6px;">
              <div id="stressSummary" class="list" style="margin-top:6px;"></div>
              Click member to plot.
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

<script>
(() => {
  // ===== Canvas & State =====
  const base = document.getElementById('base');
  const overlay = document.getElementById('overlay');
  const stressCanvas = document.getElementById('stressPanel');
  const stressBlock  = document.getElementById('stressPanelBlock');
  const ctx = base.getContext('2d');
  const ovr = overlay.getContext('2d');
  const spx = stressCanvas.getContext('2d');

  const nodeList   = document.getElementById('nodeList');
  const memberList = document.getElementById('memberList');
  const resultList = document.getElementById('resultList');
  const stressSummary = document.getElementById('stressSummary');
  const stressPlotModeSelect = document.getElementById('stressPlotMode');

  const MAX_MEMBERS = 50;
  let mode = 'draw';        
  let viewMode = 'geom';    
  let units = 'US';         

  // Frame nodes: {id,x,y, bc, Fx,Fy,Mz, ...}
  let nodes = [];
  // Members: {id,n1,n2,E,A,I,S,c,wd, Fy, shapeF, ...}
  let members = [];
  let nextNodeId = 1, nextMemberId = 1;

  let dragStart = null, hoverEndNodeId = null;
  let lastSolution = null; // Stores static result
  let collapseHistory = null; // For animation

  let selectedMemberId = null;
  let selectedNodeId = null;
  let selectedMemberForDelete = null;
  let movingNodeId = null;
  let moveOffset = {dx:0, dy:0};

  let anim = { on:false, t0:0, raf:null, scaleOverride:null };

  // View Camera
  const view = { scale: 1, offsetX: 0, offsetY: 0, userAdjusted: false };
  const MIN_SCALE = 0.2;
  const MAX_SCALE = 5;
  let isPanning = false;
  const panStart = { sx: 0, sy: 0, offsetX: 0, offsetY: 0 };

  // ===== Helpers =====
  const dist2 = (a,b,x,y) => (a-x)*(a-x)+(b-y)*(b-y);

  function worldToScreen(wx, wy){
    return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale };
  }

  function autoFitView(){
    if (nodes.length === 0){ view.scale = 1; view.offsetX = 0; view.offsetY = 0; return; }
    const bbox = modelBounds();
    const w = bbox.w; const h = bbox.h;
    if (!(w > 0) || !(h > 0)){ view.scale = 1; view.offsetX = 0; view.offsetY = 0; return; }
    const sx = (base.width  * 0.8) / w;
    const sy = (base.height * 0.8) / h;
    let s = Math.min(sx, sy);
    s = Math.max(MIN_SCALE, Math.min(MAX_SCALE, s));
    view.scale = s;
    const cx = bbox.x0 + w/2; const cy = bbox.y0 + h/2;
    view.offsetX = base.width /2 - cx * view.scale;
    view.offsetY = base.height/2 - cy * view.scale;
  }
  function autoFitIfNeeded(){ if (!view.userAdjusted) autoFitView(); }

  const nearNodeId = (x,y, tolPx=9) => {
    const tolWorld = tolPx / view.scale;
    let best=null, dmin=tolWorld*tolWorld;
    for (const n of nodes) {
      const d = dist2(n.x, n.y, x, y);
      if (d <= dmin){ best=n; dmin=d; }
    }
    return best ? best.id : null;
  };

  const nodeById   = id => nodes.find(n=>n.id===id);
  const memberById = id => members.find(m=>m.id===id);

  const pointToSegmentDistance = (P, A, B) => {
    const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy || 1e-9;
    let t = (APx*ABx + APy*ABy)/ab2; 
    t = Math.max(0,Math.min(1,t));
    const Cx=A.x+t*(B.x-A.x), Cy=A.y+t*(B.y-A.y);
    return Math.hypot(P.x-Cx, P.y-Cy);
  };
  const nearMemberId = (x,y, tolPx=6) => {
    const tolWorld = tolPx / view.scale;
    let bestId=null, best=tolWorld;
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const d=pointToSegmentDistance({x,y},a,b);
      if (d<best){best=d; bestId=m.id;}
    }
    return bestId;
  };

  function addNode(x,y){
    const id=nextNodeId++;
    nodes.push({ id,x,y, bc:'free', Fx:0,Fy:0,Mz:0, Kx:0,Ky:0,Kt:0, Wn:0 });
    refreshLists();
    return id;
  }

  function addMember(n1,n2){
    if (members.length>=MAX_MEMBERS){
      Swal.fire('Limit reached','Max members reached.','info'); return null;
    }
    const id=nextMemberId++;
    let E=29000000, A=10, I=100, S=10, c=0, wd=0, Fy=36000, shapeF=1.15, label=`M${id}`;
    if (members.length>=1){
      const t = members[members.length-1];
      ({E,A,I,S,c,wd,Fy,shapeF} = t);
    }
    members.push({ id,n1,n2,E,A,I,S,c,wd, Fy, shapeF, label });
    refreshLists();
    return id;
  }
  function deleteMember(id){
    const idx = members.findIndex(m=>m.id===id);
    if (idx<0) return;
    members.splice(idx,1);
    lastSolution = null; collapseHistory=null;
    refreshLists(); autoFitIfNeeded(); draw();
  }
  function deleteNodeWithMembers(nodeId){
    const nidx = nodes.findIndex(n=>n.id===nodeId);
    if (nidx<0) return;
    members = members.filter(m => m.n1!==nodeId && m.n2!==nodeId);
    nodes.splice(nidx,1);
    lastSolution = null; collapseHistory=null;
    refreshLists(); autoFitIfNeeded(); draw();
  }

  const yUp      = yCanvas => base.height - yCanvas;
  const yCanvas = yUpVal  => base.height - yUpVal;

  const modeBtns = ['btnDraw','btnSelect'];
  const viewBtns = ['viewGeom','viewDef','viewStressPanel'];
  function setActiveGroup(ids, activeId){
    ids.forEach(id => {
      const el = document.getElementById(id);
      if(el) el.classList.toggle('active', id===activeId);
    });
  }

  // ===== UI Actions =====
  document.getElementById('btnDraw').onclick   = () => { mode='draw'; overlay.style.cursor='crosshair'; setActiveGroup(modeBtns,'btnDraw'); draw(); };
  document.getElementById('btnSelect').onclick = () => { mode='select'; overlay.style.cursor='pointer'; setActiveGroup(modeBtns,'btnSelect'); draw(); };

  document.getElementById('viewGeom').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };
  
  document.getElementById('viewDef').onclick  = ()=>{ 
      viewMode='def'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewDef'); draw(); 
  };
  
  document.getElementById('viewStressPanel').onclick = ()=>{ viewMode='stresspanel'; toggleStressPanel(true); setActiveGroup(viewBtns,'viewStressPanel'); draw(); };
  document.getElementById('btnCloseStressPanel').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };

  document.getElementById('btnUndo').onclick = () => {
    lastSolution=null; collapseHistory=null;
    if (dragStart){ dragStart=null; hoverEndNodeId=null; draw(); return; }
    if (members.length){ members.pop(); refreshLists(); autoFitIfNeeded(); draw(); return; }
    if (nodes.length){ nodes.pop(); refreshLists(); autoFitIfNeeded(); draw(); return; }
  };
  document.getElementById('btnClear').onclick = () => {
    nodes=[]; members=[]; nextNodeId=1; nextMemberId=1; lastSolution=null; collapseHistory=null;
    selectedNodeId=null; selectedMemberId=null;
    viewMode='geom'; toggleStressPanel(false);
    setActiveGroup(modeBtns,'btnDraw'); setActiveGroup(viewBtns,'viewGeom');
    view.userAdjusted = false; autoFitView(); refreshLists(); draw();
  };

  document.getElementById('btnSaveInput').onclick = () => {
    const data={units,nodes,members};
    const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='frame_input.json'; a.click();
    URL.revokeObjectURL(url);
  };
  const fileInput = document.getElementById('fileInput');
  document.getElementById('btnLoadInput').onclick = () => fileInput.click();
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0]; if (!f) return;
    const rd = new FileReader();
    rd.onload = () => {
      try{
        const obj = JSON.parse(rd.result);
        if (!obj.nodes || !obj.members) throw new Error('Missing nodes/members');
        nodes = obj.nodes.map(n=>({
          id:n.id, x:n.x, y:n.y, bc:n.bc||'free',
          Fx:n.Fx||0, Fy:n.Fy||0, Mz:n.Mz||0, Kx:n.Kx||0, Ky:n.Ky||0, Kt:n.Kt||0, Wn:n.Wn||0
        }));        
        members = obj.members.map(m=>({
          id:m.id, n1:m.n1, n2:m.n2,
          E:m.E||0, A:m.A||0, I:m.I||0, S:m.S||0, c:m.c||0, wd:m.wd||0,
          Fy:m.Fy||36000, shapeF:m.shapeF||1.15, 
          label:m.label||`M${m.id}`
        }));
        nextNodeId = (nodes.reduce((a,n)=>Math.max(a,n.id),0) || 0) + 1;
        nextMemberId = (members.reduce((a,m)=>Math.max(a,m.id),0) || 0) + 1;
        lastSolution=null; collapseHistory=null; 
        selectedNodeId=null; selectedMemberId=null; 
        view.userAdjusted = false; autoFitView(); refreshLists(); draw();
        Swal.fire('Loaded','Input model loaded.','success');
      }catch(err){ console.error(err); Swal.fire('Load failed','Error parsing JSON','error'); }
      fileInput.value='';
    };
    rd.readAsText(f);
  });

  document.getElementById('btnUS').onclick = () => { units='US'; Swal.fire('Units set','US (in, lbs, psi)','success'); };
  document.getElementById('btnSI').onclick = () => { units='SI'; Swal.fire('Units set','SI (m, N, Pa)','success'); };

  document.getElementById('btnSolve').onclick = () => { solveFrame(false); };
  document.getElementById('btnResetView').onclick = () => { lastSolution=null; collapseHistory=null; selectedMemberId=null; draw(); };

  // ============================================
  // === COLLAPSE ANALYSIS (Incremental) Logic ===
  // ============================================
  
  document.getElementById('btnCollapse').onclick = async () => {
    // 1. Initial Linear Solution to find Critical Lambda
    const sol0 = solveFrameInternal(); // Returns solution obj or null
    if(!sol0) { Swal.fire('Error','Solver failed (unstable?)','error'); return; }

    let minLambda = Infinity;
    let criticalReason = "None";
    let critMemId = null;
    
    // Check initial critical factor
    for(const m of members) {
        const res = sol0.stress[m.id];
        const sum = sol0.stressSummary[m.id];
        if(!res || !sum) continue;
        
        // Yield
        const Mp = (m.shapeF || 1.0) * (m.S || 0) * (m.Fy || 0);
        const Mmax = sum.MabsMax;
        if(Mp > 0 && Mmax > 1e-9) {
            const lam = Mp / Mmax;
            if(lam < minLambda) { minLambda = lam; criticalReason = "Yield"; critMemId=m.id; }
        }

        // Buckling
        const n1=nodeById(m.n1), n2=nodeById(m.n2);
        const isPinned = (bc)=>bc==='simple'||bc==='rollerX'||bc==='rollerY';
        let K_val = 0.5; 
        if(isPinned(n1.bc) && isPinned(n2.bc)) K_val=1.0;
        else if(isPinned(n1.bc) || isPinned(n2.bc)) K_val=0.7;
        
        const L=res.L;
        const Pcr = (Math.PI**2 * m.E * m.I)/((K_val*L)**2);
        
        let minN = 0; for(let val of res.N) if(val<minN) minN=val;
        const Pcomp = Math.abs(minN);
        if(Pcomp > 1e-9){
            const lam = Pcr / Pcomp;
            if(lam < minLambda) { minLambda = lam; criticalReason = "Buckling"; critMemId=m.id; }
        }
    }

    if(minLambda === Infinity || minLambda > 1e6) {
        Swal.fire('No Critical Load', 'Could not determine capacity (zero load?)', 'info');
        return;
    }

    // Initialize Collapse History
    collapseHistory = [];
    
    // Frame 0: Zero state
    collapseHistory.push({
        U: new Array(sol0.Ufull.length).fill(0),
        lambda: 0,
        desc: "Unloaded"
    });

    // Frame 1: Critical State (Elastic Limit)
    const U_crit = sol0.Ufull.map(v => v * minLambda);
    collapseHistory.push({
        U: [...U_crit],
        lambda: minLambda,
        desc: `Critical Limit (λ=${minLambda.toFixed(2)}) - ${criticalReason} M${critMemId}`
    });

    // --- INCREMENTAL LOOP ---
    // Start from Critical state
    let currentTotalU = [...U_crit];
    // Stiffness modifiers: 1.0 = full stiffness. 
    // If yielded, I_fac -> 0.01. If buckled, A_fac, E_fac -> 0.05
    let stiffMod = {}; 
    members.forEach(m => stiffMod[m.id] = { I_fac: 1.0, E_fac: 1.0, A_fac: 1.0 });

    const STEPS = 2;
    const INC_PCT = 0.10; // 10% of Critical Load per step
    
    let currentLambda = minLambda;
    let logHtml = `<div style="font-size:12px;margin-bottom:6px;"><strong>Critical λ: ${minLambda.toFixed(4)}</strong> (${criticalReason} M${critMemId})</div>`;

    for(let step=1; step<=STEPS; step++){
        // 1. Check status based on TOTAL state so far to update stiffness for NEXT increment
        // We calculate internal forces based on current displacements
        const build0 = buildAnalysisModelFrame(); // Geometry only
        const internal = computeInternalEndForces(build0, currentTotalU);
        
        let newFailures = [];
        
        for(const m of members){
            const int = internal[m.id];
            // Calc max M and max Comp (approx at ends)
            const M_max_curr = Math.max(Math.abs(int.Mi), Math.abs(int.Mj));
            const N_min_curr = Math.min(int.Ni, int.Nj);
            const P_comp_curr = Math.abs(Math.min(0, N_min_curr));

            const Mp = (m.shapeF||1.0)*(m.S||0)*(m.Fy||0);
            
            const n1=nodeById(m.n1), n2=nodeById(m.n2);
            const isPinned = (bc)=>bc==='simple'||bc==='rollerX'||bc==='rollerY';
            let K_val = 0.5; 
            if(isPinned(n1.bc) && isPinned(n2.bc)) K_val=1.0;
            else if(isPinned(n1.bc) || isPinned(n2.bc)) K_val=0.7;
            const gEl = build0.geom[m.id];
            const L = gEl.L;
            const Pcr = (Math.PI**2 * m.E * m.I)/((K_val*L)**2);

            // Yield -> Hinge
            if(Mp > 0 && M_max_curr >= Mp && stiffMod[m.id].I_fac > 0.1) {
                stiffMod[m.id].I_fac = 0.01;
                newFailures.push(`M${m.id} Yld`);
            }
            // Buckle -> Soften
            if(Pcr > 0 && P_comp_curr >= Pcr && stiffMod[m.id].A_fac > 0.1) {
                stiffMod[m.id].A_fac = 0.05;
                stiffMod[m.id].E_fac = 0.05;
                newFailures.push(`M${m.id} Bkl`);
            }
        }

        if(newFailures.length > 0) logHtml += `<div style="color:#b91c1c; font-size:11px;">Step ${step}: ${newFailures.join(', ')}</div>`;

        // 2. Solve for Increment (Delta U)
        // We use solveFrameInternal with MODIFIERS.
        // The solver uses the ORIGINAL Load Vector F.
        // We want Delta F = 0.1 * Critical_Load_Magnitude * F_unit? 
        // No, we want 10% of the force vector corresponding to the Critical State.
        // F_crit = minLambda * F_app.
        // Delta F = 0.1 * F_crit = 0.1 * minLambda * F_app.
        // The solver solves K' * U_sol = F_app.
        // So Delta U = U_sol * (0.1 * minLambda).
        
        const solInc = solveFrameInternal(stiffMod); 
        if(!solInc) {
            logHtml += `<div style="color:red;">Structure Unstable at Step ${step}</div>`;
            break;
        }

        const scaleFact = INC_PCT * minLambda;
        const deltaU = solInc.Ufull.map(u => u * scaleFact);
        
        currentTotalU = currentTotalU.map((val, k) => val + deltaU[k]);
        currentLambda += scaleFact;

        collapseHistory.push({
            U: [...currentTotalU],
            lambda: currentLambda,
            desc: `+10% (λ=${currentLambda.toFixed(3)})`
        });
    }

    resultList.innerHTML = logHtml + `<div style="color:#059669; font-weight:600; margin-top:4px;">Analysis Done. Press Animate.</div>`;
    
    // Setup View
    viewMode = 'def';
    setActiveGroup(viewBtns, 'viewDef');
    
    // Create a dummy lastSolution for the static draw() to show the final state immediately
    const buildFinal = buildAnalysisModelFrame();
    const finalSublines = generateSublines(buildFinal, currentTotalU, 10);
    lastSolution = { Ufull: currentTotalU, sublines: finalSublines, stress:{}, stressSummary:{} }; 
    document.getElementById('defScale').value = 1; // Absolute displacement
    
    draw();
  };

  // ============================================
  // === ANIMATION ===
  // ============================================
  document.getElementById('btnAnimate').onclick = () => {
    if (anim.on) { stopAnim(); return; }
    startAnim();
  };

  function startAnim(){
    anim.on = true; 
    anim.t0 = 0;
    const btn = document.getElementById('btnAnimate');
    btn.textContent = 'Stop'; btn.classList.add('active');

    // If we have collapse history, animate that sequence
    if(collapseHistory && collapseHistory.length > 1) {
        const totalDuration = 5000; 
        
        const tick = (ts) => {
            if (!anim.on) return;
            if (!anim.t0) anim.t0 = ts;
            const elapsed = ts - anim.t0;
            const progress = (elapsed % totalDuration) / totalDuration; 
            
            const maxIdx = collapseHistory.length - 1;
            const virtualIdx = progress * maxIdx;
            const idxA = Math.floor(virtualIdx);
            const idxB = Math.min(maxIdx, idxA + 1);
            const t = virtualIdx - idxA;

            const UA = collapseHistory[idxA].U;
            const UB = collapseHistory[idxB].U;
            
            const U_curr = UA.map((val, k) => val * (1-t) + UB[k] * t);
            
            const build = buildAnalysisModelFrame();
            const sublines = generateSublines(build, U_curr, 10);
            
            lastSolution = { sublines: sublines, Ufull: U_curr };
            
            draw(1.0); // Pass scale=1
            
            // Label
            const lam = collapseHistory[idxA].lambda*(1-t) + collapseHistory[idxB].lambda*t;
            ctx.save(); ctx.fillStyle='black'; ctx.font='bold 14px sans-serif';
            ctx.fillText(`λ = ${lam.toFixed(3)}`, 10, 20);
            ctx.restore();

            anim.raf = requestAnimationFrame(tick);
        };
        anim.raf = requestAnimationFrame(tick);

    } else {
        // Standard Vibration
        const tick = (ts)=>{
            if (!anim.on) return;
            if (!anim.t0) anim.t0 = ts;
            const t = (ts - anim.t0)/1000;
            const base = parseFloat(document.getElementById('defScale').value)||1;
            const amp = 0.5*(1 - Math.cos(2*Math.PI*1*t));
            draw(base * amp);
            anim.raf = requestAnimationFrame(tick);
        };
        anim.raf = requestAnimationFrame(tick);
    }
  }

  function stopAnim(){
    anim.on = false; 
    if(anim.raf) cancelAnimationFrame(anim.raf);
    document.getElementById('btnAnimate').textContent = 'Animate';
    document.getElementById('btnAnimate').classList.remove('active');
    draw();
  }

  // ============================================
  // === CORE SOLVER FUNCTIONS ===
  // ============================================
  
  function solveFrameInternal(stiffMod = null){
      const build = buildAnalysisModelFrame(stiffMod);
      const { N, dofMap, K, F, geom } = build;
      
      // Loads
      for (const n of nodes){
          const base = dofMap.primary[n.id];
          if (base === undefined) continue;
          F[base+0] += n.Fx || 0; F[base+1] += n.Fy || 0; F[base+2] += n.Mz || 0;
      }
      
      // BCs
      const constrained = new Set();
      for (const n of nodes){
          const base = dofMap.primary[n.id];
          if (base === undefined) continue;
          if (n.bc === 'fixed'){ constrained.add(base+0); constrained.add(base+1); constrained.add(base+2); }
          else if (n.bc === 'simple'){ constrained.add(base+0); constrained.add(base+1); }
          else if (n.bc === 'rollerX'){ constrained.add(base+0); }
          else if (n.bc === 'rollerY'){ constrained.add(base+1); }
      }
      
      const allIdx = [...Array(N).keys()];
      const freeIdx = allIdx.filter(i => !constrained.has(i));
      if (freeIdx.length === 0) return null; 

      const Kff = matPick(K, freeIdx, freeIdx);
      const Ff  = vecPick(F, freeIdx);
      
      let Uf;
      try { Uf = numeric.solve(Kff, Ff); } catch { return null; }
      if(Uf.some(x=>!isFinite(x))) return null;
      
      const U = Array(N).fill(0);
      freeIdx.forEach((gi, k) => { U[gi] = Uf[k]; });

      const internal = computeInternalEndForces(build, U);
      
      // Basic Linear Stresses (for static output)
      const stress = {};
      const stressSummary = {};
      for (const m of members){
          const gEl = geom[m.id];
          const int = internal[m.id];
          if (!gEl || !int) continue;
          const L = gEl.L;
          const xs=[], Ns=[], Ms=[], sigTop=[], sigBot=[], Vs=[];
          let NabsMax=0, MabsMax=0;
          for(let k=0; k<=10; k++){ 
              const t=k/10; 
              const N_val = int.Ni*(1-t) + int.Nj*t;
              const M_val = int.Mi*(1-t) + int.Mj*t;
              xs.push(L*t); Ns.push(N_val); Ms.push(M_val);
              NabsMax = Math.max(NabsMax, Math.abs(N_val));
              MabsMax = Math.max(MabsMax, Math.abs(M_val));
              let sTop=0, sBot=0;
              if(m.A>0 && m.S>0){
                  const sAx = N_val/m.A; const sB = M_val/m.S;
                  sTop=sAx+sB; sBot=sAx-sB;
              }
              sigTop.push(sTop); sigBot.push(sBot);
          }
          stress[m.id] = { L, x:xs, N:Ns, M:Ms, sigmaTop:sigTop, sigmaBot:sigBot }; 
          stressSummary[m.id] = { NabsMax, MabsMax };
      }

      const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value) || 10)));
      const sublines = generateSublines(build, U, DIV);

      return { Ufull:U, dofMap, sublines, stress, stressSummary };
  }

  function solveFrame(silent=false){
      const sol = solveFrameInternal();
      if(sol){
          lastSolution = sol;
          collapseHistory = null;
          let html = nodes.map(n=>{
            const b=sol.dofMap.primary[n.id];
            return `<div>N${n.id}: ux=${round6(sol.Ufull[b])}, uy=${round6(sol.Ufull[b+1])}</div>`;
          }).join('');
          resultList.innerHTML = html;
          draw();
          if(!silent) Swal.fire('Solved', 'Static solution complete', 'success');
      } else {
          Swal.fire('Error', 'Singular Matrix or Constraints', 'error');
      }
  }

  function buildAnalysisModelFrame(modifiers = null){
    const anodes = {};
    const dofMap = { primary:{}, analysis:{} };
    let aNextId = 1;
    for (const n of nodes){
        const id = aNextId++;
        anodes[id] = { x_up: n.x, y_up: yUp(n.y), primary: n.id };
        const base = (id - 1) * 3;
        dofMap.primary[n.id] = base;
        dofMap.analysis[id]  = base;
    }
    const nA = Object.keys(anodes).length;
    const N  = nA * 3;
    const K  = zeros(N, N);
    const F  = zeros(N);
    const geom = {};

    for (const m of members){
        const ni = getAnalysisIdForPrimary(m.n1, anodes);
        const nj = getAnalysisIdForPrimary(m.n2, anodes);
        if (!ni || !nj) continue;
        const pi = anodes[ni], pj = anodes[nj];
        const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
        const L  = Math.hypot(dx, dy);
        if (L < 1e-9) continue;
        const c = dx / L, s = dy / L;
        
        let E = m.E || 0, A = m.A || 0, I = m.I || 0;
        
        if(modifiers && modifiers[m.id]){
            E *= modifiers[m.id].E_fac;
            A *= modifiers[m.id].A_fac;
            I *= modifiers[m.id].I_fac;
        }

        if (!(E > 0 && A > 0 && I > 0)) continue;
        const kLoc = frameLocalStiffness(E, A, I, L);
        const T    = frameT(c, s);
        const kG   = matMul6TKT(kLoc, T);
        const baseI = dofMap.analysis[ni], baseJ = dofMap.analysis[nj];
        const map   = [baseI, baseI+1, baseI+2, baseJ, baseJ+1, baseJ+2];
        addToGlobalVar(K, kG, map);
        geom[m.id] = { i: ni, j: nj, L, c, s, T };
    }
    return { N, dofMap, anodes, K, F, geom };
  }

  function generateSublines(build, U, divCount){
      const sublines = [];
      const { dofMap } = build; 
      for (const m of members){
          const niID = m.n1, njID = m.n2;
          const bi = dofMap.primary[niID], bj = dofMap.primary[njID];
          if(bi===undefined || bj===undefined) continue;
          const nodeI = nodeById(niID), nodeJ = nodeById(njID);
          const ui = { u: U[bi+0], v: U[bi+1] }, uj = { u: U[bj+0], v: U[bj+1] };
          const poly = [];
          for (let k=0; k<=divCount; k++){
              const t=k/divCount;
              const x_up = nodeI.x + t*(nodeJ.x-nodeI.x);
              const y_up = yUp(nodeI.y + t*(nodeJ.y-nodeI.y)); 
              poly.push({ x_up, y_up, u: ui.u*(1-t)+uj.u*t, v: ui.v*(1-t)+uj.v*t });
          }
          sublines.push(poly);
      }
      return sublines;
  }

  function computeInternalEndForces(build, U){
    const { dofMap, geom } = build;
    const internal = {};
    for (const memIdStr of Object.keys(geom)){
        const memId = parseInt(memIdStr, 10);
        const gEl   = geom[memId];
        if (!gEl) continue;
        const m = memberById(memId);
        if (!m) continue;
        const E=m.E, A=m.A, I=m.I;
        const bi = dofMap.analysis[gEl.i];
        const bj = dofMap.analysis[gEl.j];
        const ue = [ U[bi], U[bi+1], U[bi+2], U[bj], U[bj+1], U[bj+2] ];
        const u_loc = mulMatVec(gEl.T, ue);
        const kLoc = frameLocalStiffness(E, A, I, gEl.L);
        const f_loc = mulMatVec(kLoc, u_loc); 
        internal[memId] = { Ni: f_loc[0], Vi: f_loc[1], Mi: f_loc[2], Nj: f_loc[3], Vj: f_loc[4], Mj: f_loc[5] };
    }
    return internal;
  }

  // ===== Helpers =====
  function getAnalysisIdForPrimary(pid, anodes){ for (const [aid,obj] of Object.entries(anodes)){ if (obj.primary===pid) return parseInt(aid,10); } return null; }
  function addToGlobalVar(K, ke, map){ for (let r=0;r<map.length;r++){ const R=map[r]; for (let c=0;c<map.length;c++){ const C=map[c]; K[R][C] += ke[r][c]; }}}
  function matPick(A,r,c){ const M=r.length,N=c.length,O=Array(M); for(let i=0;i<M;i++){ O[i]=Array(N); for(let j=0;j<N;j++)O[i][j]=A[r[i]][c[j]]; } return O; }
  function vecPick(v,r){ return r.map(i=>v[i]); }
  function zeros(n,m){ const A=Array(n); for(let i=0;i<n;i++) if(m) A[i]=Array(m).fill(0); else A[i]=0; return A; }
  function frameLocalStiffness(E,A,I,L){
      const k=Array(6).fill(0).map(()=>Array(6).fill(0));
      const a=E*A/L, b=12*E*I/(L*L*L), c=6*E*I/(L*L), d=4*E*I/L, e=2*E*I/L;
      k[0][0]=a; k[0][3]=-a; k[3][3]=a; k[3][0]=-a;
      k[1][1]=b; k[1][2]=c; k[1][4]=-b; k[1][5]=c;
      k[2][1]=c; k[2][2]=d; k[2][4]=-c; k[2][5]=e;
      k[4][1]=-b; k[4][2]=-c; k[4][4]=b; k[4][5]=-c;
      k[5][1]=c; k[5][2]=e; k[5][4]=-c; k[5][5]=d;
      return k;
  }
  function frameT(c,s){ return [ [c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0], [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1] ]; }
  function matMul6TKT(k,T){ const KT=matMul(k,T); const TT=transpose(T); return matMul(TT,KT); }
  function matMul(A,B){
      const r=A.length, c=B[0].length, p=B.length;
      const C=Array(r).fill(0).map(()=>Array(c).fill(0));
      for(let i=0;i<r;i++) for(let j=0;j<c;j++) for(let k=0;k<p;k++) C[i][j]+=A[i][k]*B[k][j];
      return C;
  }
  function mulMatVec(M, v){
    const n = M.length; const out = new Array(n).fill(0);
    for (let i = 0; i < n; i++){ let sum = 0; const row = M[i]; for (let j = 0; j < row.length; j++) sum += row[j] * v[j]; out[i] = sum; }
    return out;
  }
  function transpose(A){ return A[0].map((_,c)=>A.map(r=>r[c])); }
  function round6(x){ return Math.round(x*1e6)/1e6; }
  
  function drawCoordTag(g, x, y, text){
    g.save(); g.fillStyle='rgba(0,0,0,0.7)'; g.fillRect(x,y,80,16); g.fillStyle='#fff'; g.fillText(text,x+4,y+12); g.restore();
  }
  function modelBounds(){
      if(nodes.length===0)return {x0:0,y0:0,w:100,h:100};
      let x0=Infinity,x1=-Infinity,y0=Infinity,y1=-Infinity;
      nodes.forEach(n=>{ x0=Math.min(x0,n.x); x1=Math.max(x1,n.x); y0=Math.min(y0,n.y); y1=Math.max(y1,n.y); });
      return {x0,y0,w:x1-x0||1,h:y1-y0||1};
  }
  function refreshLists(){ 
      nodeList.innerHTML = nodes.map(n=>`<div>N${n.id}</div>`).join('');
      memberList.innerHTML = members.map(m=>`<div>M${m.id}: Fy=${m.Fy}</div>`).join('');
  }
  
  function toggleStressPanel(show){
    stressBlock.style.display = show ? 'block' : 'none';
    document.getElementById('stressPanelHint').style.display = show ? 'block' : 'none';
    if(show){ 
        stressCanvas.style.width='100%'; stressCanvas.width=stressCanvas.parentElement.clientWidth; stressCanvas.height=260; 
        if(selectedMemberId) plotStressPanel();
    }
  }
  
  function plotStressPanel(){
      const spx = stressCanvas.getContext('2d');
      spx.clearRect(0,0,stressCanvas.width,stressCanvas.height);
      if (!lastSolution || !lastSolution.stress || !selectedMemberId){
          spx.fillText('Select member',10,20); return;
      }
      const mData = lastSolution.stress[selectedMemberId];
      if(!mData) return;
      
      const mode = document.getElementById('stressPlotMode').value;
      let arr = (mode==='sigma')?mData.sigmaTop : (mode==='N'?mData.N : (mode==='V'?mData.V : mData.M));
      let min=Infinity, max=-Infinity;
      for(let v of arr){ min=Math.min(min,v); max=Math.max(max,v); }
      if(!isFinite(min)) { min=-1; max=1; }
      if(max===min){ min-=1; max+=1; }
      
      const W=stressCanvas.width, H=stressCanvas.height;
      spx.beginPath(); spx.strokeStyle='#000';
      for(let i=0; i<arr.length; i++){
          const x = (i/(arr.length-1))*W;
          const y = H - ((arr[i]-min)/(max-min))*(H-20) - 10;
          if(i===0) spx.moveTo(x,y); else spx.lineTo(x,y);
      }
      spx.stroke();
      spx.fillText(`Max: ${max.toFixed(2)}`, 10, 15);
      spx.fillText(`Min: ${min.toFixed(2)}`, 10, H-5);
  }

  function drawBCGlyph(g, bc){
    // Not used in main UI but required by editNode dialog if called
    g.clearRect(0,0,g.canvas.width,g.canvas.height);
    g.save(); g.translate(30, g.canvas.height-20); g.strokeStyle='#aaa'; g.lineWidth=1;
    g.beginPath(); g.moveTo(-10,0); g.lineTo(140,0); g.stroke();
    g.fillStyle='#000'; g.beginPath(); g.arc(0,0,4,0,Math.PI*2); g.fill();
    g.restore();
  }

  function draw(scaleOverride){
    ctx.clearRect(0,0,base.width,base.height);
    ovr.clearRect(0,0,overlay.width,overlay.height);
    drawGrid(ctx);
    
    // Members
    ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#222'; ctx.font='12px system-ui'; ctx.fillStyle='#000';
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, M=worldToScreen(mx,my);
      ctx.fillText(m.label||`M${m.id}`, M.x+4, M.y-6);
    }
    ctx.restore();

    // Nodes
    for (const n of nodes){
      const p=worldToScreen(n.x,n.y);
      ctx.save(); ctx.fillStyle='#000';
      if(n.bc==='fixed') ctx.fillRect(p.x-8,p.y-8,16,16);
      else if(n.bc==='simple'){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-6,p.y+10); ctx.lineTo(p.x+6,p.y+10); ctx.fill(); }
      
      ctx.fillStyle='#1d4ed8'; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
      
      ctx.strokeStyle='#db2777'; ctx.lineWidth=2;
      if(n.Fx){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+30*(n.Fx>0?1:-1),p.y); ctx.stroke(); }
      if(n.Fy){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x,p.y+30*(n.Fy<0?1:-1)); ctx.stroke(); }
      ctx.restore();
      drawCoordTag(ctx, p.x+10, p.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
    }
    
    if(viewMode==='def' && lastSolution && lastSolution.sublines){
        let scale = parseFloat(document.getElementById('defScale').value)||1;
        if(scaleOverride !== undefined) scale = scaleOverride;
        
        ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#e11d48';
        for(const poly of lastSolution.sublines){
            ctx.beginPath();
            for(let k=0; k<poly.length; k++){
                const p=poly[k];
                const S=worldToScreen(p.x_up + scale*p.u, yCanvas(p.y_up + scale*p.v));
                if(k===0) ctx.moveTo(S.x,S.y); else ctx.lineTo(S.x,S.y);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    drawSelection();
  }

  function drawSelection(){
      if(selectedNodeId){
          const n=nodeById(selectedNodeId), p=worldToScreen(n.x,n.y);
          ovr.save(); ovr.lineWidth=3; ovr.strokeStyle='#10b981'; ovr.beginPath(); ovr.arc(p.x,p.y,12,0,Math.PI*2); ovr.stroke(); ovr.restore();
      }
      if(selectedMemberForDelete){
          const m=memberById(selectedMemberForDelete), a=nodeById(m.n1), b=nodeById(m.n2);
          const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
          ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#f59e0b'; ovr.beginPath(); ovr.moveTo(A.x,A.y); ovr.lineTo(B.x,B.y); ovr.stroke(); ovr.restore();
      }
  }

  function drawGrid(g){
      g.save(); g.lineWidth=1; g.strokeStyle='#eee';
      const bbox=modelBounds();
      g.restore();
  }

  if (stressPlotModeSelect){
    stressPlotModeSelect.addEventListener('change', () => {
      if (viewMode === 'stresspanel') plotStressPanel();
    });
  }

  // Kickoff
  refreshLists();
  draw();

})();
</script>
</body>
</html>
