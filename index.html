<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Frame Collapse — Incremental Analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:18px; --canvas-w:700px; --canvas-h:560px; --panel-w:680px; }
  body { background:#f6f7fb; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
  h2 { margin:0 0 10px; }
  .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
  .col { background:#fff; border:1px solid #ddd; border-radius:12px; padding:var(--pad); }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  .controls.split { justify-content:flex-start; }
  button, select, input[type="number"], input[type="text"]{
    height:32px; padding:0 10px; border:1px solid #bbb; border-radius:8px; background:#eee; font-size:14px; color:#333;
  }
  input[type="range"]{ width:120px; }
  button { cursor:pointer; transition:background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
  button.primary { background:#eee; color:#333; border-color:#bbb; }
  button.ghost   { background:#eee; color:#333; border-color:#bbb; }
  button.action  { background:#e0f2fe; color:#0369a1; border-color:#7dd3fc; font-weight:600; }
  button.active  { background:#cfd8e3; color:#555; border-color:#9aa6b2; box-shadow: inset 0 0 0 1px #9aa6b2; cursor:default; }

  .labelbtn { pointer-events:none; opacity:1; font-weight:600; }
  .stack { display:flex; flex-direction:column; gap:8px; }

  .panel-row { display: flex; gap: 10px; margin-top: 10px; }
  .panel-half { flex: 1; min-width: 0; }

  #wrap { position:relative; width:var(--canvas-w); height:var(--canvas-h); background:#fff; border:1px solid #ccc; border-radius:8px; }

  /* Only the main drawing canvases are absolute */
  #wrap canvas { position:absolute; inset:0; }

  #base { z-index:1; }
  #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

  /* Ensure plot canvases stay in normal document flow */
  #loadVsStepCanvas,
  #loadVsDispCanvas,
  #stressPanel {
    position: static;
    inset: auto;
    display: block;
  }

  .panel { width:var(--panel-w); }
  .list { font-size:13px; max-height:240px; overflow:auto; border:1px dashed #ddd; padding:8px; border-radius:8px; }
  .hint { color:#666; font-size:12px; }
  .swal2-popup { font-size:12px !important; width:auto !important; min-width:360px !important; }
  .swal2-input, .swal2-select { font-size:12px !important; height:28px !important; }

  #stressPanelBlock { display:none; }
  #stressPanel { width:100%; height:260px; position:static; border:1px solid #ccc; border-radius:8px; }
</style>
</head>

<body>
  <h2>FRAME COLLAPSE (Incremental)</h2>

  <div class="controls split" id="rowTop">
    <button id="btnDraw"   class="primary">Draw Members</button>
    <button id="btnSelect" class="ghost">Select/Edit</button>
    <button id="btnUndo"  class="ghost">Undo</button>
    <button id="btnClear" class="ghost">Clear</button>
    <span class="hint" style="margin-left:6px;">
      Double-click member to set Yield (Fy) & ShapeF.
    </span>
  </div>

  <div class="row">
    <div class="col">
      <div id="wrap">
        <canvas id="base"    width="700" height="560"></canvas>
        <canvas id="overlay" width="700" height="560"></canvas>
      </div>

      <div class="controls split" style="margin-top:10px; gap:12px;">
        <button class="ghost labelbtn" disabled>Seg Divs</button>
        <input id="divCount"  type="number" min="1" max="50" value="10" style="width:60px;">

        <button id="btnSolve" class="primary">Solve Static</button>
        <button id="btnCollapse" class="action">Run Collapse Analysis</button>

        <div style="width:1px; height:24px; background:#ccc; margin:0 4px;"></div>

        <button id="btnAnimate" class="ghost">Animate</button>
        <button id="viewStressPanel" class="ghost">Stresses</button>
        <button id="btnLoadPlots" class="ghost">Load Plots</button>

        <button class="ghost labelbtn" disabled>Def Scale</button>
        <input id="defScale"  type="number" step="any" value="1" style="width:60px;">

        <button id="btnFitView" class="ghost">Fit to View</button>
        <button id="btnResetView" class="ghost">Reset</button>
      </div>
    </div>

    <div class="col panel stack">
      <div>
        <div><strong>Units (display only)</strong></div>
        <div class="controls">
          <button id="btnUS" class="ghost">US (in, lbs, psi)</button>
          <button id="btnSI" class="ghost">SI (m, N, Pa)</button>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong>Nodes</strong>
            <span class="hint">Edit X/Y</span>
          </div>
          <div id="nodeList" class="list"></div>
        </div>

        <div class="panel-half">
          <div><strong>Members</strong></div>
          <div id="memberList" class="list"></div>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div><strong>Analysis Log</strong></div>
          <div id="resultList" class="list"></div>

          <div id="loadPlotBlock" style="margin-top:10px;">
            <div style="margin-bottom:4px;"><strong>Load Analysis</strong></div>
            <canvas id="loadVsStepCanvas" width="320" height="120" style="border:1px solid #ccc; border-radius:8px; margin-bottom:8px; background:#f9fafb;"></canvas>
            <canvas id="loadVsDispCanvas" width="320" height="120" style="border:1px solid #ccc; border-radius:8px; background:#f9fafb;"></canvas>
          </div>
        </div>

        <div class="panel-half">
          <div id="stressPanelBlock">
            <div class="controls" style="justify-content:space-between; align-items:center;">
              <strong>Stress Panel</strong>
              <div style="display:flex;align-items:center;gap:6px;">
                <label class="ghost labelbtn" disabled>Plot</label>
                <select id="stressPlotMode" style="height:26px;padding:0 6px;">
                  <option value="sigma">σ (top / bottom)</option>
                  <option value="N">N (axial)</option>
                  <option value="M">M (moment)</option>
                </select>
                <button id="btnCloseStressPanel" class="ghost">Close</button>
              </div>
            </div>
            <canvas id="stressPanel"></canvas>
            <div id="stressPanelHint" class="hint" style="margin-top:6px;">
              <div id="stressSummary" class="list" style="margin-top:6px;"></div>
              Click member to plot.
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

<script>
(() => {
  // ===== Canvas & State =====
  const base = document.getElementById('base');
  const overlay = document.getElementById('overlay');
  const stressCanvas = document.getElementById('stressPanel');
  const stressBlock  = document.getElementById('stressPanelBlock');
  const ctx = base.getContext('2d');
  const ovr = overlay.getContext('2d');

  const nodeList   = document.getElementById('nodeList');
  const memberList = document.getElementById('memberList');
  const resultList = document.getElementById('resultList');
  const stressSummary = document.getElementById('stressSummary');
  const stressPlotModeSelect = document.getElementById('stressPlotMode');

  const MAX_MEMBERS = 50;
  let mode = 'draw';
  let viewMode = 'geom';
  let units = 'US';

  // Frame nodes: {id,x,y, bc, Fx,Fy,Mz, ...}
  let nodes = [];
  // Members: {id,n1,n2,E,A,I,S,c,wd, Fy, shapeF, materialBehavior, ...}
  let members = [];
  let nextNodeId = 1, nextMemberId = 1;

  let dragStart = null, hoverEndNodeId = null;
  let lastSolution = null;         // Stores result for drawing
  let collapseHistory = null;      // For animation + plots

  let selectedMemberId = null;
  let selectedNodeId = null;
  let selectedMemberForDelete = null;
  let movingNodeId = null;
  let moveOffset = {dx:0, dy:0};

  let anim = { on:false, t0:0, raf:null };

  // View Camera
  const view = { scale: 1, offsetX: 0, offsetY: 0, userAdjusted: false };
  const MIN_SCALE = 0.2;
  const MAX_SCALE = 5;
  let isPanning = false;
  const panStart = { sx: 0, sy: 0, offsetX: 0, offsetY: 0 };

  // ===== UI Button Groups for Active State =====
  const modeBtns = ['btnDraw', 'btnSelect'];
  const viewBtns = ['viewStressPanel'];

  function setActiveGroup(group, activeId) {
    group.forEach(id => {
      const btn = document.getElementById(id);
      if (!btn) return;
      if (id === activeId) btn.classList.add('active');
      else btn.classList.remove('active');
    });
  }

  function toggleLoadPlot(show){
    const blk = document.getElementById('loadPlotBlock');
    blk.style.display = show ? 'block' : 'none';
    if (show && collapseHistory && collapseHistory.length > 1) plotLoadAnalysis();
  }

  // ===============================
  // ===== CORE SOLVER FUNCTIONS ===
  // ===============================

  /**
   * Build an analysis model (primary + internal nodes).
   * IMPORTANT UPDATE:
   * - This now supports "geometry update" using a provided Ugeom (full DOF vector).
   *   If Ugeom is provided, EVERY analysis node (including internal/secondary) has its
   *   coordinates updated as:
   *     x_up = x0_up + Ugeom[base+0]
   *     y_up = y0_up + Ugeom[base+1]
   *   This is the key change for your requirement (secondary nodes updated each increment).
   *
   * - Local stiffness is also modified by hinge softening (moment-only cap model).
   */
  function buildAnalysisModelFrame(stiffMod = null, hingeState = null, Ugeom = null){
    const anodes = {};
    const dofMap = { primary:{}, analysis:{} };
    let aNextId = 1;

    const yUp = y => base.height - y;

    // Add primary nodes (store original geometry x0_up,y0_up)
    for (const n of nodes){
      const id = aNextId++;
      const x0_up = n.x;
      const y0_up = yUp(n.y);
      anodes[id] = { x0_up, y0_up, x_up:x0_up, y_up:y0_up, primary: n.id, isPrimary: true };
      const baseDOF = (id - 1) * 3;
      dofMap.primary[n.id] = baseDOF;
      dofMap.analysis[id]  = baseDOF;
    }

    // Add internal nodes along members (store original geometry x0_up,y0_up)
    const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value) || 10)));
    const internalNodeMap = {};

    for(const m of members){
      const n1 = nodeById(m.n1), n2 = nodeById(m.n2);
      if(!n1 || !n2) continue;

      internalNodeMap[m.id] = [];
      for(let k=1; k<DIV; k++){
        const t = k / DIV;
        const id = aNextId++;

        const x0_up = n1.x + t * (n2.x - n1.x);
        const y0_up = yUp(n1.y + t * (n2.y - n1.y));

        anodes[id] = { x0_up, y0_up, x_up:x0_up, y_up:y0_up, primary: null, isPrimary: false, memberId: m.id, t: t };

        const baseDOF = (id - 1) * 3;
        dofMap.analysis[id] = baseDOF;
        internalNodeMap[m.id].push(id);
      }
    }

    // APPLY GEOMETRY UPDATE TO ALL ANALYSIS NODES (primary + internal) IF Ugeom PROVIDED
    if (Ugeom && Array.isArray(Ugeom)){
      for (const [aidStr, aobj] of Object.entries(anodes)){
        const aid = parseInt(aidStr, 10);
        const b = dofMap.analysis[aid];
        if (b === undefined) continue;
        aobj.x_up = aobj.x0_up + (Ugeom[b+0] || 0);
        aobj.y_up = aobj.y0_up + (Ugeom[b+1] || 0);
      }
    }

    const nA = Object.keys(anodes).length;
    const N  = nA * 3;
    const K  = zeros(N, N);
    const F  = zeros(N);
    const geom = {};

    // Elements (assembled along subdivided chain)
    for (const m of members){
      const ni_primary = getAnalysisIdForPrimary(m.n1, anodes);
      const nj_primary = getAnalysisIdForPrimary(m.n2, anodes);
      if (!ni_primary || !nj_primary) continue;

      const nodeChain = [ni_primary, ...internalNodeMap[m.id], nj_primary];

      for(let idx=0; idx<nodeChain.length-1; idx++){
        const ni = nodeChain[idx];
        const nj = nodeChain[idx+1];
        const pi = anodes[ni], pj = anodes[nj];

        const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
        const L  = Math.hypot(dx, dy);
        if (L < 1e-9) continue;
        const c = dx / L, s = dy / L;

        let E = m.E || 0, A = m.A || 0, I = m.I || 0;
        if(stiffMod && stiffMod[m.id]){
          E *= stiffMod[m.id].E_fac;
          A *= stiffMod[m.id].A_fac;
          I *= stiffMod[m.id].I_fac;
        }
        if (!(E > 0 && A > 0 && I > 0)) continue;

        // Base local stiffness
        let kLoc = frameLocalStiffness(E, A, I, L);

        // Hinge softening ONLY applies to the full member ends, not every sub-element.
        // We apply softening on the FIRST and LAST sub-element, at the corresponding end DOFs.
        if (hingeState && hingeState[m.id]){
          const hs = hingeState[m.id];
          const eps = (hs.eps !== undefined) ? hs.eps : 1e-4;

          // Sub-element local DOFs: [u_i, v_i, th_i, u_j, v_j, th_j]
          // Apply end-i softening to first segment's th_i (index 2)
          if (idx === 0 && hs.i && hs.i.active){
            kLoc = applyRotSoftening(kLoc, 2, eps);
          }
          // Apply end-j softening to last segment's th_j (index 5)
          if (idx === nodeChain.length-2 && hs.j && hs.j.active){
            kLoc = applyRotSoftening(kLoc, 5, eps);
          }
        }

        const T    = frameT(c, s);
        const kG   = matMul6TKT(kLoc, T);
        const baseI = dofMap.analysis[ni], baseJ = dofMap.analysis[nj];
        const map   = [baseI, baseI+1, baseI+2, baseJ, baseJ+1, baseJ+2];
        addToGlobalVar(K, kG, map);
      }

      // Store overall member geom (based on current analysis-node geometry)
      const pi = anodes[ni_primary], pj = anodes[nj_primary];
      const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
      const L = Math.hypot(dx, dy);
      const c = dx / L, s = dy / L;
      const T = frameT(c, s);
      geom[m.id] = { i: ni_primary, j: nj_primary, L, c, s, T, nodeChain };
    }

    return { N, dofMap, anodes, K, F, geom, internalNodeMap };
  }

  /**
   * Linear solve on current geometry (optionally geometry-updated by Ugeom),
   * with hinge softening in K assembly if hingeState provided.
   */
  function solveFrameInternal(stiffMod = null, hingeState = null, Ugeom = null, externalLoadsOverride = null){
    const build = buildAnalysisModelFrame(stiffMod, hingeState, Ugeom);
    const { N, dofMap, K, F, geom } = build;

    // Loads (either current nodes loads or explicit override)
    if (externalLoadsOverride && externalLoadsOverride.length === N){
      for (let i=0;i<N;i++) F[i] += externalLoadsOverride[i];
    } else {
      for (const n of nodes){
        const base = dofMap.primary[n.id];
        if (base === undefined) continue;
        F[base+0] += n.Fx || 0;
        F[base+1] += n.Fy || 0;
        F[base+2] += n.Mz || 0;
      }
    }

    // BCs
    const constrained = new Set();
    for (const n of nodes){
      const base = dofMap.primary[n.id];
      if (base === undefined) continue;
      if (n.bc === 'fixed'){ constrained.add(base+0); constrained.add(base+1); constrained.add(base+2); }
      else if (n.bc === 'simple'){ constrained.add(base+0); constrained.add(base+1); }
      else if (n.bc === 'rollerX'){ constrained.add(base+0); }
      else if (n.bc === 'rollerY'){ constrained.add(base+1); }
    }

    const allIdx = [...Array(N).keys()];
    const freeIdx = allIdx.filter(i => !constrained.has(i));
    if (freeIdx.length === 0) return null;

    const Kff = matPick(K, freeIdx, freeIdx);
    const Ff  = vecPick(F, freeIdx);

    let Uf;
    try { Uf = numeric.solve(Kff, Ff); } catch { return null; }
    if(Uf.some(x=>!isFinite(x))) return null;

    const U = Array(N).fill(0);
    freeIdx.forEach((gi, k) => { U[gi] = Uf[k]; });

    const internal = computeInternalEndForces(build, U);

    // Basic linear stresses
    const stress = {};
    const stressSummaryObj = {};
    for (const m of members){
      const gEl = geom[m.id];
      const int = internal[m.id];
      if (!gEl || !int) continue;
      const L = gEl.L;
      const xs=[], Ns=[], Ms=[], sigTop=[], sigBot=[];
      let NabsMax=0, MabsMax=0;
      for(let k=0; k<=10; k++){
        const t=k/10;
        const N_val = int.Ni*(1-t) + int.Nj*t;
        const M_val = int.Mi*(1-t) + int.Mj*t;
        xs.push(L*t); Ns.push(N_val); Ms.push(M_val);
        NabsMax = Math.max(NabsMax, Math.abs(N_val));
        MabsMax = Math.max(MabsMax, Math.abs(M_val));
        let sTop=0, sBot=0;
        if(m.A>0 && m.S>0){
          const sAx = N_val/m.A; const sB = M_val/m.S;
          sTop=sAx+sB; sBot=sAx-sB;
        }
        sigTop.push(sTop); sigBot.push(sBot);
      }
      stress[m.id] = { L, x:xs, N:Ns, M:Ms, sigmaTop:sigTop, sigmaBot:sigBot };
      stressSummaryObj[m.id] = { NabsMax, MabsMax };
    }

    const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value) || 10)));
    const sublines = generateSublines(build, U, DIV);

    return { Ufull:U, dofMap, sublines, stress, stressSummary: stressSummaryObj, internal, build };
  }

  /**
   * Nonlinear incremental solve at fixed lambda using:
   * - Geometry update for ALL analysis nodes each iteration (secondary nodes included)
   * - Hinge state with moment capping implemented via:
   *    (1) tangent softening at yielded end rotations
   *    (2) per-iteration "moment correction" loads applied at nodal Mz DOFs to enforce cap
   *
   * Returns {U, hingeState, converged, iters, maxViolation}
   */
  function solveNonlinearAtLambda(lambda, baseLoadVec, stiffMod, hingeState, Ustart){
    const MAX_IT = 12;
    const TOL_U = 1e-6;
    const TOL_M = 1e-3; // moment cap tolerance in same units as member end moments
    const relax = 0.75; // load correction relaxation to improve stability

    let U = (Ustart && Ustart.length) ? Ustart.slice() : null;
    let corr = null; // plastic moment correction vector (length N), built after first model build
    let Nlast = null;

    let maxViolation = 0;

    for (let it=1; it<=MAX_IT; it++){
      // Build with geometry update using current U guess (or zeros first pass)
      if (!U){
        // need N to init
        const b0 = buildAnalysisModelFrame(stiffMod, hingeState, null);
        U = new Array(b0.N).fill(0);
      }

      const build = buildAnalysisModelFrame(stiffMod, hingeState, U);
      const N = build.N;
      Nlast = N;

      if (!corr) corr = new Array(N).fill(0);

      // External load at this lambda
      const Fext = new Array(N).fill(0);
      for (let i=0;i<N;i++) Fext[i] = lambda * (baseLoadVec[i] || 0) + (corr[i] || 0);

      const sol = solveFrameInternal(stiffMod, hingeState, U, Fext);
      if (!sol) return { U:null, hingeState, converged:false, iters:it, maxViolation:Infinity };

      const Un = sol.Ufull;

      // Update hinge states + compute new correction vector
      let newHingeActivated = false;
      const newCorr = new Array(N).fill(0);
      maxViolation = 0;

      for (const m of members){
        const hs = hingeState[m.id];
        if (!hs) continue;

        // brittle handling (keep your existing behavior: if brittle triggers, member essentially removed)
        // For now we only implement ductile caps as requested.
        const mat = (m.materialBehavior || 'ductile');

        // Capacity
        const Mp = (m.shapeF || 1.0) * (m.S || 0) * (m.Fy || 0);
        hs.i.Mp = Mp; hs.j.Mp = Mp;

        // End moments from current solve
        const int = sol.internal[m.id];
        if (!int) continue;

        // Map member end moments to primary node rotational DOFs (Mz DOF = base+2)
        const bI = sol.dofMap.primary[m.n1];
        const bJ = sol.dofMap.primary[m.n2];
        if (bI === undefined || bJ === undefined) continue;

        // i-end
        if (mat === 'ductile' && Mp > 0){
          const Mi = int.Mi;
          const overI = Math.abs(Mi) - Mp;
          maxViolation = Math.max(maxViolation, Math.max(0, overI));

          if (overI > TOL_M){
            const sgn = (Mi >= 0) ? 1 : -1;
            if (!hs.i.active){
              hs.i.active = true;
              hs.i.sign = sgn;
              newHingeActivated = true;
            }
            // Correction moment to apply at node DOF to bring Mi back to cap.
            // Apply -relax*(Mi - sgn*Mp) to nodal Mz DOF.
            const dM = Mi - sgn * Mp;
            newCorr[bI+2] += -relax * dM;
          } else if (hs.i.active){
            // Maintain residual cap: keep no additional correction if within tolerance.
          }
        } else if (mat === 'brittle' && Mp > 0){
          // Not requested in this step; leaving as-is (handled by stiffMod elsewhere if you want).
        }

        // j-end
        if (mat === 'ductile' && Mp > 0){
          const Mj = int.Mj;
          const overJ = Math.abs(Mj) - Mp;
          maxViolation = Math.max(maxViolation, Math.max(0, overJ));

          if (overJ > TOL_M){
            const sgn = (Mj >= 0) ? 1 : -1;
            if (!hs.j.active){
              hs.j.active = true;
              hs.j.sign = sgn;
              newHingeActivated = true;
            }
            const dM = Mj - sgn * Mp;
            newCorr[bJ+2] += -relax * dM;
          }
        }
      }

      // Convergence check (geometry + plastic enforcement)
      const duMax = maxAbsDiff(Un, U);

      // Accept updated state
      U = Un;
      corr = newCorr;

      if (duMax < TOL_U && maxViolation <= TOL_M && !newHingeActivated){
        return { U, hingeState, converged:true, iters:it, maxViolation };
      }

      // If hinges just activated, continue iterating at same lambda
    }

    return { U, hingeState, converged:false, iters:MAX_IT, maxViolation };
  }

  function computeInternalEndForces(build, U){
    const { dofMap, geom } = build;
    const internal = {};
    for (const memIdStr of Object.keys(geom)){
      const memId = parseInt(memIdStr, 10);
      const gEl   = geom[memId];
      if (!gEl) continue;
      const m = memberById(memId);
      if (!m) continue;
      const E=m.E, A=m.A, I=m.I;
      const bi = dofMap.analysis[gEl.i];
      const bj = dofMap.analysis[gEl.j];
      const ue = [ U[bi], U[bi+1], U[bi+2], U[bj], U[bj+1], U[bj+2] ];
      const u_loc = mulMatVec(gEl.T, ue);
      const kLoc = frameLocalStiffness(E, A, I, gEl.L);
      const f_loc = mulMatVec(kLoc, u_loc);
      internal[memId] = { Ni: f_loc[0], Vi: f_loc[1], Mi: f_loc[2], Nj: f_loc[3], Vj: f_loc[4], Mj: f_loc[5] };
    }
    return internal;
  }

  function generateSublines(build, U, divCount){
    const sublines = [];
    const { dofMap, anodes, internalNodeMap } = build;
    for (const m of members){
      const ni_analysis = getAnalysisIdForPrimary(m.n1, anodes);
      const nj_analysis = getAnalysisIdForPrimary(m.n2, anodes);
      if(!ni_analysis || !nj_analysis) continue;

      const nodeChain = [ni_analysis];
      if(internalNodeMap && internalNodeMap[m.id]) nodeChain.push(...internalNodeMap[m.id]);
      nodeChain.push(nj_analysis);

      const poly = [];
      for(const anodeId of nodeChain){
        const anode = anodes[anodeId];
        const baseDOF = dofMap.analysis[anodeId];
        if(baseDOF !== undefined){
          const u = U[baseDOF] || 0;
          const v = U[baseDOF+1] || 0;
          poly.push({ x0_up: anode.x0_up, y0_up: anode.y0_up, u, v });
        }
      }
      sublines.push(poly);
    }
    return sublines;
  }

  function toggleStressPanel(show){
    stressBlock.style.display = show ? 'block' : 'none';
    document.getElementById('stressPanelHint').style.display = show ? 'block' : 'none';
    if(show){
      stressCanvas.style.width='100%';
      stressCanvas.width=stressCanvas.parentElement.clientWidth;
      stressCanvas.height=260;
      if(selectedMemberId) plotStressPanel();
    }
  }

  // =========================
  // ===== MATH HELPERS ======
  // =========================
  function getAnalysisIdForPrimary(pid, anodes){
    for (const [aid,obj] of Object.entries(anodes)){
      if (obj.primary===pid) return parseInt(aid,10);
    }
    return null;
  }
  function addToGlobalVar(K, ke, map){
    for (let r=0;r<map.length;r++){
      const R=map[r];
      for (let c=0;c<map.length;c++){
        const C=map[c];
        K[R][C] += ke[r][c];
      }
    }
  }
  function matPick(A,r,c){
    const M=r.length,N=c.length,O=Array(M);
    for(let i=0;i<M;i++){
      O[i]=Array(N);
      for(let j=0;j<N;j++) O[i][j]=A[r[i]][c[j]];
    }
    return O;
  }
  function vecPick(v,r){ return r.map(i=>v[i]); }
  function zeros(n,m){
    const A=Array(n);
    for(let i=0;i<n;i++) if(m) A[i]=Array(m).fill(0); else A[i]=0;
    return A;
  }
  function frameLocalStiffness(E,A,I,L){
    const k=Array(6).fill(0).map(()=>Array(6).fill(0));
    const a=E*A/L, b=12*E*I/(L*L*L), c=6*E*I/(L*L), d=4*E*I/L, e=2*E*I/L;
    k[0][0]=a; k[0][3]=-a; k[3][3]=a; k[3][0]=-a;
    k[1][1]=b; k[1][2]=c; k[1][4]=-b; k[1][5]=c;
    k[2][1]=c; k[2][2]=d; k[2][4]=-c; k[2][5]=e;
    k[4][1]=-b; k[4][2]=-c; k[4][4]=b; k[4][5]=-c;
    k[5][1]=c; k[5][2]=e; k[5][4]=-c; k[5][5]=d;
    return k;
  }
  function frameT(c,s){
    return [
      [c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0],
      [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1]
    ];
  }
  function matMul6TKT(k,T){
    const KT=matMul(k,T);
    const TT=transpose(T);
    return matMul(TT,KT);
  }
  function matMul(A,B){
    const r=A.length, c=B[0].length, p=B.length;
    const C=Array(r).fill(0).map(()=>Array(c).fill(0));
    for(let i=0;i<r;i++) for(let j=0;j<c;j++) for(let k=0;k<p;k++) C[i][j]+=A[i][k]*B[k][j];
    return C;
  }
  function mulMatVec(M, v){
    const n = M.length; const out = new Array(n).fill(0);
    for (let i = 0; i < n; i++){
      let sum = 0; const row = M[i];
      for (let j = 0; j < row.length; j++) sum += row[j] * v[j];
      out[i] = sum;
    }
    return out;
  }
  function transpose(A){ return A[0].map((_,c)=>A.map(r=>r[c])); }
  function round6(x){ return Math.round(x*1e6)/1e6; }
  function dist2(x1,y1,x2,y2){ return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); }
  function maxAbsDiff(a,b){
    let m=0;
    for (let i=0;i<a.length;i++){
      const d = Math.abs((a[i]||0)-(b[i]||0));
      if (d>m) m=d;
    }
    return m;
  }

  // Rotational softening helper (soften row/col idx in 6x6)
  function applyRotSoftening(kLoc, rotIdx, eps){
    const k = kLoc.map(row=>row.slice());
    for (let j=0;j<6;j++){
      k[rotIdx][j] *= eps;
      k[j][rotIdx] *= eps;
    }
    // keep a tiny diagonal to prevent singular local block
    if (Math.abs(k[rotIdx][rotIdx]) < 1e-12) k[rotIdx][rotIdx] = eps;
    return k;
  }

  // ===== UI Actions =====
  document.getElementById('btnDraw').onclick   = () => { mode='draw'; overlay.style.cursor='crosshair'; setActiveGroup(modeBtns,'btnDraw'); draw(); };
  document.getElementById('btnSelect').onclick = () => { mode='select'; overlay.style.cursor='pointer'; setActiveGroup(modeBtns,'btnSelect'); draw(); };

  document.getElementById('viewStressPanel').onclick = ()=> {
    viewMode='stresspanel';
    toggleStressPanel(true);
    toggleLoadPlot(false);
    setActiveGroup(viewBtns,'viewStressPanel');
    draw();
  };
  document.getElementById('btnCloseStressPanel').onclick = ()=> {
    viewMode='geom';
    toggleStressPanel(false);
    setActiveGroup(viewBtns,'');
    draw();
  };

  document.getElementById('btnLoadPlots').onclick = ()=> {
    viewMode='geom';
    toggleStressPanel(false);
    setActiveGroup(viewBtns,'');
    toggleLoadPlot(true);
    draw();
  };

  document.getElementById('btnUndo').onclick = () => {
    lastSolution=null; collapseHistory=null;
    if (dragStart){ dragStart=null; hoverEndNodeId=null; draw(); return; }
    if (members.length){ members.pop(); refreshLists(); draw(); return; }
    if (nodes.length){ nodes.pop(); refreshLists(); draw(); return; }
  };
  document.getElementById('btnClear').onclick = () => {
    nodes=[]; members=[]; nextNodeId=1; nextMemberId=1; lastSolution=null; collapseHistory=null;
    selectedNodeId=null; selectedMemberId=null;
    viewMode='geom'; toggleStressPanel(false);
    setActiveGroup(modeBtns,'btnDraw'); setActiveGroup(viewBtns,'');
    view.scale = 1; view.offsetX = base.width / 2; view.offsetY = base.height / 2; view.userAdjusted = false;
    refreshLists(); draw();
  };

  document.getElementById('btnUS').onclick = () => { units='US'; Swal.fire('Units set','US (in, lbs, psi)','success'); };
  document.getElementById('btnSI').onclick = () => { units='SI'; Swal.fire('Units set','SI (m, N, Pa)','success'); };

  document.getElementById('btnSolve').onclick = () => {
    const sol = solveFrameInternal();
    if(sol){
      lastSolution = sol;
      collapseHistory = null;
      let html = nodes.map(n=>{
        const b=sol.dofMap.primary[n.id];
        return `<div>N${n.id}: ux=${round6(sol.Ufull[b])}, uy=${round6(sol.Ufull[b+1])}</div>`;
      }).join('');
      resultList.innerHTML = html;
      toggleLoadPlot(false);
      draw();
      Swal.fire('Solved', 'Static solution complete', 'success');
    } else {
      Swal.fire('Error', 'Singular Matrix or Constraints', 'error');
    }
  };

  document.getElementById('btnResetView').onclick = () => { lastSolution=null; collapseHistory=null; selectedMemberId=null; draw(); };
  document.getElementById('btnFitView').onclick = () => { autoFitView(); view.userAdjusted = true; draw(); };

  // ============================================
  // === COLLAPSE ANALYSIS (Incremental) Logic ===
  // ============================================
  document.getElementById('btnCollapse').onclick = async () => {
    // Base linear check
    const sol0 = solveFrameInternal();
    if(!sol0) { Swal.fire('Error','Solver failed (unstable?)','error'); return; }

    // Build base load vector in analysis DOFs (primary only)
    const buildBase = buildAnalysisModelFrame();
    const N = buildBase.N;

    const baseLoadVec = new Array(N).fill(0);
    for (const n of nodes){
      const b = buildBase.dofMap.primary[n.id];
      if (b === undefined) continue;
      baseLoadVec[b+0] += n.Fx || 0;
      baseLoadVec[b+1] += n.Fy || 0;
      baseLoadVec[b+2] += n.Mz || 0;
    }

    // Initialize hinge state per member (moment-only cap)
    const hingeState = {};
    for (const m of members){
      hingeState[m.id] = {
        eps: 1e-4, // softened tangent factor at yielded end rotations
        i: { active:false, Mp:0, sign:1 },
        j: { active:false, Mp:0, sign:1 }
      };
    }

    // Stiffness modifiers for brittle removal etc. (kept, but we are not doing Euler buckling)
    let stiffMod = {};
    members.forEach(m => stiffMod[m.id] = { I_fac: 1.0, E_fac: 1.0, A_fac: 1.0 });

    // Increments
    const MAX_STEPS = 1000;   // per your request
    const dLambda = 0.01;     // default; you can tune based on load magnitudes
    let lambda = 0;

    // History
    collapseHistory = [];
    collapseHistory.push({
      U: new Array(N).fill(0),
      lambda: 0,
      desc: "Unloaded",
      nodePositions: nodes.map(n => ({id:n.id, x:n.x, y:n.y}))
    });

    let U = new Array(N).fill(0);
    let logHtml = `<div style="font-size:12px;margin-bottom:6px;"><strong>Nonlinear Incremental w/ Plastic Moment Caps</strong></div>`;
    logHtml += `<div style="font-size:11px;color:#666;">MAX_STEPS=${MAX_STEPS}, dλ=${dLambda}</div>`;
    logHtml += `<div style="font-size:11px;color:#666;">Secondary (internal) nodes updated EVERY iteration via U-geometry</div>`;
    logHtml += `<div style="font-size:11px;color:#666;">Random seeding: <strong>OFF</strong></div>`;

    let structureStable = true;

    for (let step=1; step<=MAX_STEPS && structureStable; step++){
      lambda += dLambda;

      // Per-increment Newton loop implemented inside solveNonlinearAtLambda
      const nl = solveNonlinearAtLambda(lambda, baseLoadVec, stiffMod, hingeState, U);

      if (!nl.U || !isFinite(nl.maxViolation)){
        logHtml += `<div style="color:#b91c1c; font-weight:700; margin-top:6px;">COLLAPSE: K not solvable at step ${step} (λ=${lambda.toFixed(4)})</div>`;
        structureStable = false;
        break;
      }

      U = nl.U;

      // Update primary node positions for viewing/history (internal nodes handled inside model build)
      // NOTE: This is for display only; solver uses analysis-node geometry update internally.
      for (const n of nodes){
        const b = buildBase.dofMap.primary[n.id];
        if (b === undefined) continue;
        n.x = (n.x) + 0; // keep x as "model coords"; we store display positions below
        n.y = (n.y) + 0;
      }

      const nodePositions = nodes.map(n=>{
        const b = buildBase.dofMap.primary[n.id];
        return { id:n.id, x: (n.x + (U[b+0]||0)), y: (n.y + (U[b+1]||0)) };
      });

      // Log hinge events (newly active this increment)
      const newly = [];
      for (const m of members){
        const hs = hingeState[m.id];
        if (!hs) continue;
        if (hs.i.active || hs.j.active){
          // show which ends are active
          const ends = [];
          if (hs.i.active) ends.push('i');
          if (hs.j.active) ends.push('j');
          newly.push(`M${m.id}[${ends.join(',')}]`);
        }
      }

      if (step % 10 === 0 || nl.maxViolation > 1e-3){
        logHtml += `<div style="font-size:11px;color:#334155;">Step ${step}: λ=${lambda.toFixed(3)} | iters=${nl.iters} | max(Mcap viol)=${nl.maxViolation.toFixed(3)}</div>`;
      }

      collapseHistory.push({
        U: U.slice(),
        lambda,
        desc: `Step ${step} (λ=${lambda.toFixed(3)})`,
        nodePositions
      });

      // Simple runaway detection
      const umax = Math.max(...U.map(v=>Math.abs(v||0)));
      if (!isFinite(umax) || umax > 1e6){
        logHtml += `<div style="color:#b91c1c; font-weight:700; margin-top:6px;">COLLAPSE: displacement runaway at step ${step} (λ=${lambda.toFixed(4)})</div>`;
        structureStable = false;
        break;
      }
    }

    if (structureStable){
      logHtml += `<div style="color:#059669; font-weight:700; margin-top:6px;">Reached MAX_STEPS without singularity. Final λ=${lambda.toFixed(4)}</div>`;
    }

    resultList.innerHTML = logHtml + `<div style="color:#059669; font-weight:600; margin-top:6px;">Complete. Animate to view. Load Plots available in Results.</div>`;

    toggleStressPanel(false);
    setActiveGroup(viewBtns,'');
    toggleLoadPlot(true);

    // Update lastSolution for display using final U (includes internal node deformation in drawing)
    const buildFinal = buildAnalysisModelFrame(stiffMod, hingeState, U);
    const finalSublines = generateSublines(buildFinal, U, 10);
    lastSolution = { Ufull: U, sublines: finalSublines, stress:{}, stressSummary:{} };

    document.getElementById('defScale').value = 1;
    draw();
  };

  // ============================================
  // === ANIMATION ===
  // ============================================
  document.getElementById('btnAnimate').onclick = () => {
    if (anim.on) { stopAnim(); return; }
    startAnim();
  };

  function startAnim(){
    anim.on = true;
    anim.t0 = 0;
    const btn = document.getElementById('btnAnimate');
    btn.textContent = 'Stop';
    btn.classList.add('active');

    if (collapseHistory && collapseHistory.length > 1) {
      const maxIdx = collapseHistory.length - 1;
      const msPerStep = 150;

      let lastStep = -1;

      const tick = (ts) => {
        if (!anim.on) return;
        if (!anim.t0) anim.t0 = ts;

        const elapsed = ts - anim.t0;

        const stepRaw = Math.floor(elapsed / msPerStep);
        const step = stepRaw % (maxIdx + 1);

        if (step !== lastStep) {
          lastStep = step;

          // For display: update primary nodes to stored positions (or keep original if missing)
          const pos = collapseHistory[step].nodePositions;
          if (pos) {
            for (const n of nodes) {
              const p = pos.find(q => q.id === n.id);
              if (p) { n.x = p.x; n.y = p.y; }
            }
          }

          const build = buildAnalysisModelFrame(null, null, collapseHistory[step].U);
          const U = collapseHistory[step].U || new Array(build.N).fill(0);
          const sublines = generateSublines(build, U, 10);
          lastSolution = { sublines, Ufull: U };

          draw(1.0);

          ctx.save();
          ctx.fillStyle = 'black';
          ctx.font = 'bold 14px sans-serif';
          ctx.fillText(`λ = ${collapseHistory[step].lambda.toFixed(3)}, step ${step}/${maxIdx}`, 10, 20);
          ctx.restore();
        }

        anim.raf = requestAnimationFrame(tick);
      };

      anim.raf = requestAnimationFrame(tick);
      return;
    }

    const tick = (ts)=>{
      if (!anim.on) return;
      if (!anim.t0) anim.t0 = ts;
      const t = (ts - anim.t0)/1000;
      const base = parseFloat(document.getElementById('defScale').value)||1;
      const amp = 0.5*(1 - Math.cos(2*Math.PI*1*t));
      draw(base * amp);
      anim.raf = requestAnimationFrame(tick);
    };
    anim.raf = requestAnimationFrame(tick);
  }

  function stopAnim(){
    anim.on = false;
    if(anim.raf) cancelAnimationFrame(anim.raf);
    document.getElementById('btnAnimate').textContent = 'Animate';
    document.getElementById('btnAnimate').classList.remove('active');

    // Restore original primary positions from frame 0 (nodePositions)
    if(collapseHistory && collapseHistory[0] && collapseHistory[0].nodePositions){
      for(const origNode of collapseHistory[0].nodePositions){
        const n = nodeById(origNode.id);
        if(n){ n.x = origNode.x; n.y = origNode.y; }
      }
    }
    draw();
  }

  // ===== Helpers =====
  function worldToScreen(wx, wy){ return { x: wx * view.scale + view.offsetX, y: wy * view.scale + view.offsetY }; }
  function screenToWorld(sx, sy){ return { x: (sx - view.offsetX) / view.scale, y: (sy - view.offsetY) / view.scale }; }
  function autoFitView(){
    if (nodes.length === 0){ view.scale = 1; view.offsetX = 0; view.offsetY = 0; return; }
    const bbox = modelBounds();
    const w = bbox.w; const h = bbox.h;
    if (!(w > 0) || !(h > 0)){ view.scale = 1; view.offsetX = 0; view.offsetY = 0; return; }
    const sx = (base.width  * 0.8) / w;
    const sy = (base.height * 0.8) / h;
    let s = Math.min(sx, sy);
    s = Math.max(MIN_SCALE, Math.min(MAX_SCALE, s));
    view.scale = s;
    const cx = bbox.x0 + w/2; const cy = bbox.y0 + h/2;
    view.offsetX = base.width /2 - cx * view.scale;
    view.offsetY = base.height/2 - cy * view.scale;
  }
  const nearNodeId = (x,y, tolPx=9) => {
    const tolWorld = tolPx / view.scale;
    let best=null, dmin=tolWorld*tolWorld;
    for (const n of nodes) {
      const d = dist2(n.x, n.y, x, y);
      if (d <= dmin){ best=n; dmin=d; }
    }
    return best ? best.id : null;
  };
  const nodeById   = id => nodes.find(n=>n.id===id);
  const memberById = id => members.find(m=>m.id===id);
  const pointToSegmentDistance = (P, A, B) => {
    const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y;
    const ab2 = ABx*ABx + ABy*ABy || 1e-9;
    let t = (APx*ABx + APy*ABy)/ab2;
    t = Math.max(0,Math.min(1,t));
    const Cx=A.x+t*(B.x-A.x), Cy=A.y+t*(B.y-A.y);
    return Math.hypot(P.x-Cx, P.y-Cy);
  };
  const nearMemberId = (x,y, tolPx=6) => {
    const tolWorld = tolPx / view.scale;
    let bestId=null, best=tolWorld;
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const d=pointToSegmentDistance({x,y},a,b);
      if (d<best){best=d; bestId=m.id;}
    }
    return bestId;
  };

  function addNode(x,y){
    const id=nextNodeId++;
    nodes.push({ id,x,y, bc:'free', Fx:0,Fy:0,Mz:0, Kx:0,Ky:0,Kt:0, Wn:0 });
    refreshLists(); return id;
  }
  function addMember(n1,n2){
    if (members.length>=MAX_MEMBERS){ Swal.fire('Limit','Max members','info'); return null; }
    const id=nextMemberId++;
    let E=29000000, A=10, I=100, S=10, c=0, wd=0, Fy=36000, shapeF=1.15, label=`M${id}`, materialBehavior='ductile';
    if (members.length>=1){ const t = members[members.length-1]; ({E,A,I,S,c,wd,Fy,shapeF,materialBehavior} = t); }
    members.push({ id,n1,n2,E,A,I,S,c,wd, Fy, shapeF, label, materialBehavior });
    refreshLists(); return id;
  }
  function deleteMember(id){
    const idx = members.findIndex(m=>m.id===id); if (idx<0) return;
    members.splice(idx,1); lastSolution = null; collapseHistory=null; refreshLists(); draw();
  }
  function deleteNodeWithMembers(nodeId){
    const nidx = nodes.findIndex(n=>n.id===nodeId); if (nidx<0) return;
    members = members.filter(m => m.n1!==nodeId && m.n2!==nodeId);
    nodes.splice(nidx,1); lastSolution = null; collapseHistory=null; refreshLists(); draw();
  }

  const yUp = yCanvas => base.height - yCanvas;
  const yCanvas = yUpVal  => base.height - yUpVal;
  function mousePos(e){
    const r=overlay.getBoundingClientRect();
    return { x:(e.clientX-r.left-view.offsetX)/view.scale, y:(e.clientY-r.top-view.offsetY)/view.scale, sx:e.clientX-r.left, sy:e.clientY-r.top };
  }

  function editNode(node){
    const bcOptions = [
      {value:'free', text:'Free'},
      {value:'simple', text:'Pinned'},
      {value:'fixed', text:'Fixed'},
      {value:'rollerX', text:'Roller-X'},
      {value:'rollerY', text:'Roller-Y'}
    ];
    const html = `
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
        <label style="grid-column:1/3; font-weight:600;">BC</label>
        <select id="bc" class="swal2-select" style="grid-column:1/3;">
          ${bcOptions.map(o=>`<option value="${o.value}" ${node.bc===o.value?'selected':''}>${o.text}</option>`).join('')}
        </select>
        <label>Fx</label><input id="Fx" class="swal2-input" type="number" step="any" value="${node.Fx}">
        <label>Fy</label><input id="Fy" class="swal2-input" type="number" step="any" value="${node.Fy}">
        <label>Mz</label><input id="Mz" class="swal2-input" type="number" step="any" value="${node.Mz||0}">
      </div>`;
    Swal.fire({
      title:`Node ${node.id}`,
      html,
      showCancelButton:true,
      confirmButtonText:'Save',
      preConfirm:()=>{
        const v=id=>parseFloat(document.getElementById(id).value)||0;
        return { bc:document.getElementById('bc').value, Fx:v('Fx'), Fy:v('Fy'), Mz:v('Mz') };
      }
    }).then(res=>{
      if(res.isConfirmed){
        Object.assign(node,res.value);
        lastSolution=null;
        collapseHistory=null;
        refreshLists();
        draw();
      }
    });
  }

  function editMember(m){
    const html = `
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:center;">
        <label>Label</label><input id="label" class="swal2-input" type="text" value="${m.label||''}">
        <div style="grid-column:1/3;height:1px;background:#eee;margin:4px 0;"></div>
        <label>E</label><input id="E" class="swal2-input" type="number" step="any" value="${m.E}">
        <label>A</label><input id="A" class="swal2-input" type="number" step="any" value="${m.A}">
        <label>I</label><input id="I" class="swal2-input" type="number" step="any" value="${m.I}">
        <label>S (Section Mod)</label><input id="S" class="swal2-input" type="number" step="any" value="${m.S}">
        <label>Fy (Yield Stress)</label><input id="Fy" class="swal2-input" type="number" step="any" value="${m.Fy||36000}">
        <label>Shape Factor</label><input id="shapeF" class="swal2-input" type="number" step="any" value="${m.shapeF||1.15}">
        <label>Material</label>
        <select id="materialBehavior" class="swal2-select" style="grid-column:2/3;">
          <option value="ductile" ${(m.materialBehavior||'ductile')==='ductile'?'selected':''}>Ductile (Steel)</option>
          <option value="brittle" ${m.materialBehavior==='brittle'?'selected':''}>Brittle (Wood)</option>
        </select>
      </div>`;
    Swal.fire({
      title:`Member ${m.id}`,
      html,
      showCancelButton:true,
      confirmButtonText:'Save',
      width: '400px',
      preConfirm:()=>{
        const v=id=>parseFloat(document.getElementById(id)?.value)||0;
        return {
          label:document.getElementById('label').value,
          E:v('E'), A:v('A'), I:v('I'), S:v('S'), Fy:v('Fy'), shapeF:v('shapeF'),
          materialBehavior:document.getElementById('materialBehavior').value
        };
      }
    }).then(res=>{
      if(res.isConfirmed){
        Object.assign(m,res.value);
        lastSolution=null;
        collapseHistory=null;
        refreshLists();
        draw();
      }
    });
  }

  function plotLoadAnalysis(){
    if(!collapseHistory || collapseHistory.length < 2) return;

    const cvs1 = document.getElementById('loadVsStepCanvas');
    const cvs2 = document.getElementById('loadVsDispCanvas');
    const ctx1 = cvs1.getContext('2d');
    const ctx2 = cvs2.getContext('2d');

    const lambdas = collapseHistory.map(h => h.lambda);
    const steps = collapseHistory.map((h, i) => i);
    const maxDisps = collapseHistory.map(h => {
      if(!h.U) return 0;
      return Math.max(...h.U.map(v=>Math.abs(v||0)));
    });

    const W1 = cvs1.width, H1 = cvs1.height;
    const W2 = cvs2.width, H2 = cvs2.height;
    const pad = {l:50, r:20, t:20, b:30};

    // Plot 1
    ctx1.clearRect(0, 0, W1, H1);
    ctx1.fillStyle = '#f9fafb';
    ctx1.fillRect(0, 0, W1, H1);

    const maxLambda = Math.max(...lambdas);
    const maxStep = Math.max(1, steps.length - 1);

    ctx1.strokeStyle = '#e5e7eb';
    ctx1.lineWidth = 1;
    for(let i=0; i<=5; i++){
      const y = pad.t + (H1 - pad.t - pad.b) * i / 5;
      ctx1.beginPath(); ctx1.moveTo(pad.l, y); ctx1.lineTo(W1 - pad.r, y); ctx1.stroke();
    }

    ctx1.strokeStyle = '#3b82f6';
    ctx1.lineWidth = 2;
    ctx1.beginPath();
    for(let i=0; i<steps.length; i++){
      const x = pad.l + (W1 - pad.l - pad.r) * steps[i] / maxStep;
      const y = (H1 - pad.b) - (H1 - pad.t - pad.b) * lambdas[i] / (maxLambda * 1.1);
      if(i === 0) ctx1.moveTo(x, y);
      else ctx1.lineTo(x, y);
    }
    ctx1.stroke();

    ctx1.fillStyle = '#000';
    ctx1.font = '11px sans-serif';
    ctx1.fillText('Load Factor (λ)', pad.l, 15);
    ctx1.fillText('Step', W1/2, H1 - 5);

    // Plot 2
    ctx2.clearRect(0, 0, W2, H2);
    ctx2.fillStyle = '#f9fafb';
    ctx2.fillRect(0, 0, W2, H2);

    const maxDisp = Math.max(1e-9, ...maxDisps);

    ctx2.strokeStyle = '#e5e7eb';
    ctx2.lineWidth = 1;
    for(let i=0; i<=5; i++){
      const y = pad.t + (H2 - pad.t - pad.b) * i / 5;
      ctx2.beginPath(); ctx2.moveTo(pad.l, y); ctx2.lineTo(W2 - pad.r, y); ctx2.stroke();
    }

    ctx2.strokeStyle = '#10b981';
    ctx2.lineWidth = 2;
    ctx2.beginPath();
    for(let i=0; i<maxDisps.length; i++){
      const x = pad.l + (W2 - pad.l - pad.r) * maxDisps[i] / (maxDisp * 1.1);
      const y = (H2 - pad.b) - (H2 - pad.t - pad.b) * lambdas[i] / (maxLambda * 1.1);
      if(i === 0) ctx2.moveTo(x, y);
      else ctx2.lineTo(x, y);
    }
    ctx2.stroke();

    ctx2.fillStyle = '#000';
    ctx2.font = '11px sans-serif';
    ctx2.fillText('Load Factor (λ)', pad.l, 15);
    ctx2.fillText('Max Displacement', W2/2, H2 - 5);
  }

  function plotStressPanel(){
    const spx = stressCanvas.getContext('2d');
    spx.clearRect(0,0,stressCanvas.width,stressCanvas.height);
    if (!lastSolution || !lastSolution.stress || !selectedMemberId){
      spx.fillText('Select member',10,20); return;
    }
    const mData = lastSolution.stress[selectedMemberId];
    if(!mData) return;
    const mode = document.getElementById('stressPlotMode').value;
    let arr = (mode==='sigma')?mData.sigmaTop : (mode==='N'?mData.N : mData.M);
    let min=Infinity, max=-Infinity;
    for(let v of arr){ min=Math.min(min,v); max=Math.max(max,v); }
    if(!isFinite(min)) { min=-1; max=1; }
    if(max===min){ min-=1; max+=1; }
    const W=stressCanvas.width, H=stressCanvas.height;
    spx.beginPath(); spx.strokeStyle='#000';
    for(let i=0; i<arr.length; i++){
      const x = (i/(arr.length-1))*W;
      const y = H - ((arr[i]-min)/(max-min))*(H-20) - 10;
      if(i===0) spx.moveTo(x,y); else spx.lineTo(x,y);
    }
    spx.stroke();
    spx.fillText(`Max: ${max.toFixed(2)}`, 10, 15);
    spx.fillText(`Min: ${min.toFixed(2)}`, 10, H-5);
  }

  if (stressPlotModeSelect){
    stressPlotModeSelect.addEventListener('change', () => { if (viewMode === 'stresspanel') plotStressPanel(); });
  }

  function draw(scaleOverride){
    ctx.clearRect(0,0,base.width,base.height);
    ovr.clearRect(0,0,overlay.width,overlay.height);
    drawGrid(ctx);

    // undeformed members
    ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#222'; ctx.font='12px system-ui'; ctx.fillStyle='#000';
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      if(!a || !b) continue;
      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, M=worldToScreen(mx,my);
      ctx.fillText(m.label||`M${m.id}`, M.x+4, M.y-6);
    }
    ctx.restore();

    // nodes + loads
    for (const n of nodes){
      const p=worldToScreen(n.x,n.y);
      ctx.save(); ctx.fillStyle='#000';
      if(n.bc==='fixed') ctx.fillRect(p.x-8,p.y-8,16,16);
      else if(n.bc==='simple'){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-6,p.y+10); ctx.lineTo(p.x+6,p.y+10); ctx.fill(); }
      ctx.fillStyle='#1d4ed8'; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#db2777'; ctx.lineWidth=2;
      if(n.Fx){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+30*(n.Fx>0?1:-1),p.y); ctx.stroke(); }
      if(n.Fy){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x,p.y+30*(n.Fy<0?1:-1)); ctx.stroke(); }
      ctx.restore();
      drawCoordTag(ctx, p.x+10, p.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
    }

    // deformed shape (apply scale to displacement)
    if (lastSolution && lastSolution.sublines){
      let scale = parseFloat(document.getElementById('defScale').value) || 1;
      if (scaleOverride !== undefined) scale = scaleOverride;

      ctx.save(); ctx.lineWidth = 3; ctx.strokeStyle = '#e11d48';

      for (const poly of lastSolution.sublines){
        ctx.beginPath();
        for (let k=0; k<poly.length; k++){
          const p = poly[k];
          const x0 = (p.x0_up !== undefined) ? p.x0_up : (p.x_up - (p.u||0));
          const y0 = (p.y0_up !== undefined) ? p.y0_up : (p.y_up - (p.v||0));
          const x_up = x0 + scale * (p.u || 0);
          const y_up = y0 + scale * (p.v || 0);

          const S = worldToScreen(x_up, yCanvas(y_up));
          if (k === 0) ctx.moveTo(S.x, S.y);
          else ctx.lineTo(S.x, S.y);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    drawSelection();
  }

  // Draw-mode preview line (survives redraw while dragging)
  if (mode === 'draw' && dragStart) {
    if (draw._mx !== undefined && draw._my !== undefined) {
      const p0 = worldToScreen(dragStart.x, dragStart.y);
      const p1 = worldToScreen(draw._mx, draw._my);

      ovr.save();
      ovr.lineWidth = 2;
      ovr.setLineDash([6,4]);
      ovr.strokeStyle = '#3a86ff';
      ovr.beginPath();
      ovr.moveTo(p0.x, p0.y);
      ovr.lineTo(p1.x, p1.y);
      ovr.stroke();
      ovr.restore();
    }
  }

  function drawSelection(){
    if(selectedNodeId){
      const n=nodeById(selectedNodeId); if(n){
        const p=worldToScreen(n.x,n.y);
        ovr.save(); ovr.lineWidth=3; ovr.strokeStyle='#10b981'; ovr.beginPath(); ovr.arc(p.x,p.y,12,0,Math.PI*2); ovr.stroke(); ovr.restore();
      }
    }
    if(selectedMemberForDelete){
      const m=memberById(selectedMemberForDelete);
      if(m){
        const a=nodeById(m.n1), b=nodeById(m.n2);
        if(a && b){
          const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
          ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#f59e0b'; ovr.beginPath(); ovr.moveTo(A.x,A.y); ovr.lineTo(B.x,B.y); ovr.stroke(); ovr.restore();
        }
      }
    }
  }

  function drawGrid(g){
    g.save();
    g.lineWidth=1;
    g.strokeStyle='#eee';
    g.restore();
  }

  function drawCoordTag(g, x, y, text){
    g.save(); g.fillStyle='rgba(0,0,0,0.7)'; g.fillRect(x,y,80,16); g.fillStyle='#fff'; g.fillText(text,x+4,y+12); g.restore();
  }

  function modelBounds(){
    if(nodes.length===0)return {x0:0,y0:0,w:100,h:100};
    let x0=Infinity,x1=-Infinity,y0=Infinity,y1=-Infinity;
    nodes.forEach(n=>{ x0=Math.min(x0,n.x); x1=Math.max(x1,n.x); y0=Math.min(y0,n.y); y1=Math.max(y1,n.y); });
    return {x0,y0,w:x1-x0||1,h:y1-y0||1};
  }

  function refreshLists(){
    nodeList.innerHTML = nodes.map(n=>`<div>N${n.id}</div>`).join('');
    memberList.innerHTML = members.map(m=>`<div>M${m.id}: Fy=${m.Fy}</div>`).join('');
  }

  // ===== Overlay Events =====
  overlay.addEventListener('contextmenu', e => e.preventDefault());
  overlay.addEventListener('mousedown', (e)=>{
    if (e.button === 2){
      isPanning = true; panStart.sx = e.clientX; panStart.sy = e.clientY;
      panStart.offsetX = view.offsetX; panStart.offsetY = view.offsetY;
      view.userAdjusted = true; overlay.style.cursor = 'grab'; e.preventDefault(); return;
    }
    const {x,y}=mousePos(e);
    if (mode==='draw'){
      const nid=nearNodeId(x,y);
      let startNode, created=false, existing=false;
      if (nid){ startNode=nodeById(nid); existing=true; }
      else { const id=addNode(x,y); startNode=nodeById(id); created=true; }
      dragStart={x:startNode.x, y:startNode.y, nodeId:startNode.id, createdStart:created, existingStart:existing};
      hoverEndNodeId=null;
    } else if (mode==='select'){
      const nid = nearNodeId(x,y,8);
      if (nid){
        const n = nodeById(nid); movingNodeId = nid;
        moveOffset.dx = x - n.x; moveOffset.dy = y - n.y;
        selectedNodeId = nid; overlay.style.cursor='grabbing';
      }
      dragStart={x,y,nodeId:null,createdStart:false}; hoverEndNodeId=null;
    }
    draw();
  });

  overlay.addEventListener('mousemove', (e)=>{
    const {x,y}=mousePos(e);
    if (isPanning){
      view.offsetX = panStart.offsetX + (e.clientX - panStart.sx);
      view.offsetY = panStart.offsetY + (e.clientY - panStart.sy);
      view.userAdjusted = true; draw(); return;
    }

    // Store last mouse position for preview line drawn inside draw()
    draw._mx = x;
    draw._my = y;

    if (mode==='draw' && dragStart){
      hoverEndNodeId = nearNodeId(x,y);
      draw();
      return;
    }

    draw();

    if (mode==='select'){
      if(movingNodeId!==null){
        const n=nodeById(movingNodeId); n.x=x-moveOffset.dx; n.y=y-moveOffset.dy;
        lastSolution=null; collapseHistory=null; draw(); return;
      }
      const mid=nearMemberId(x,y,6);
      const nid=nearNodeId(x,y,8);
      if(mid){
        const m=memberById(mid), a=nodeById(m.n1), b=nodeById(m.n2);
        const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
        ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#ff006e';
        ovr.beginPath(); ovr.moveTo(A.x,A.y); ovr.lineTo(B.x,B.y); ovr.stroke(); ovr.restore();
        overlay.style.cursor='pointer';
      } else if(nid){
        const n=nodeById(nid), p=worldToScreen(n.x,n.y);
        ovr.save(); ovr.fillStyle='rgba(16,185,129,0.22)';
        ovr.beginPath(); ovr.arc(p.x,p.y,10,0,Math.PI*2); ovr.fill(); ovr.restore();
        overlay.style.cursor='pointer';
        drawCoordTag(ovr, p.x+12, p.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
      } else { overlay.style.cursor='pointer'; }
    }
  });

  overlay.addEventListener('mouseup', (e)=>{
    if (isPanning && e.button === 2){ isPanning = false; overlay.style.cursor = (mode === 'draw') ? 'crosshair' : 'pointer'; return; }
    const {x,y}=mousePos(e);
    if (mode==='draw' && dragStart){
      let nid=nearNodeId(x,y);
      let endNode;
      if (nid){ endNode=nodeById(nid); } else { const id=addNode(x,y); endNode=nodeById(id); }
      if (endNode.id===dragStart.nodeId){
        if (dragStart.createdStart){ nodes.pop(); }
        dragStart=null; refreshLists(); draw(); return;
      }
      const mid=addMember(dragStart.nodeId, endNode.id);
      dragStart=null; refreshLists(); draw();
      if (mid) editMember(memberById(mid));
      return;
    }
    if (mode==='select'){
      const mid=nearMemberId(x,y,6);
      const nid=nearNodeId(x,y,8);
      if (movingNodeId!==null){ movingNodeId=null; draw(); return; }
      if (viewMode==='stresspanel' && mid){ selectedMemberId = mid; plotStressPanel(); return; }
      if (nid){ selectedNodeId=nid; selectedMemberForDelete=null; draw(); return; }
      if (mid){ selectedMemberForDelete=mid; selectedNodeId=null; draw(); return; }
      selectedNodeId=null; selectedMemberForDelete=null; draw();
    }
  });

  overlay.addEventListener('dblclick', (e)=>{
    if (mode!=='select') return;
    const {x,y}=mousePos(e);
    const nid=nearNodeId(x,y,8);
    const mid=nearMemberId(x,y,6);
    if (nid){ editNode(nodeById(nid)); draw(); return; }
    if (mid){ editMember(memberById(mid)); draw(); return; }
  });

  overlay.addEventListener('wheel', (e)=>{
    e.preventDefault(); if(nodes.length===0)return;
    const rect = overlay.getBoundingClientRect();
    const sx = e.clientX - rect.left; const sy = e.clientY - rect.top;
    const world = screenToWorld(sx,sy);
    const delta = e.deltaY < 0 ? 1.1 : 0.9;
    let newScale = view.scale * delta;
    newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
    view.scale = newScale;
    view.offsetX = sx - world.x * view.scale;
    view.offsetY = sy - world.y * view.scale;
    view.userAdjusted = true; draw();
  }, { passive:false });

  // Fix A/B/C: do not delete geometry when typing in inputs; protect SweetAlert inputs too
  document.addEventListener('keydown', (e) => {
    if (mode !== 'select') return;

    const t = e.target;
    const isTypingContext =
      t && (
        t.tagName === 'INPUT' ||
        t.tagName === 'TEXTAREA' ||
        t.tagName === 'SELECT' ||
        t.isContentEditable
      );

    const swalOpen = !!document.querySelector('.swal2-container');
    if (isTypingContext || swalOpen) return;

    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedNodeId) {
        deleteNodeWithMembers(selectedNodeId);
        selectedNodeId = null;
        e.preventDefault();
      } else if (selectedMemberForDelete) {
        deleteMember(selectedMemberForDelete);
        selectedMemberForDelete = null;
        e.preventDefault();
      }
    }
  });

  // Kickoff
  view.scale = 1;
  view.offsetX = base.width / 2;
  view.offsetY = base.height / 2;
  refreshLists();
  toggleLoadPlot(false);
  draw();

})();
</script>
</body>
</html>





