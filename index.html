<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Frame Collapse — Incremental Analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:18px; --canvas-w:700px; --canvas-h:560px; --panel-w:680px; }
  body { background:#f6f7fb; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:20px; }
  h2 { margin:0 0 10px; }
  .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
  .col { background:#fff; border:1px solid #ddd; border-radius:12px; padding:var(--pad); }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  .controls.split { justify-content:flex-start; }
  button, select, input[type="number"], input[type="text"]{
    height:32px; padding:0 10px; border:1px solid #bbb; border-radius:8px; background:#eee; font-size:14px; color:#333;
  }
  input[type="range"]{ width:120px; }
  button { cursor:pointer; transition:background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
  button.primary { background:#eee; color:#333; border-color:#bbb; }
  button.ghost   { background:#eee; color:#333; border-color:#bbb; }
  button.action  { background:#e0f2fe; color:#0369a1; border-color:#7dd3fc; font-weight:600; }
  button.active  { background:#cfd8e3; color:#555; border-color:#9aa6b2; box-shadow: inset 0 0 0 1px #9aa6b2; cursor:default; }

  .labelbtn { pointer-events:none; opacity:1; font-weight:600; }
  .stack { display:flex; flex-direction:column; gap:8px; }
  
  .panel-row { display: flex; gap: 10px; margin-top: 10px; }
  .panel-half { flex: 1; min-width: 0; }

  #wrap { position:relative; width:var(--canvas-w); height:var(--canvas-h); background:#fff; border:1px solid #ccc; border-radius:8px; }
  canvas { position:absolute; inset:0; }
  #base { z-index:1; } #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

  .panel { width:var(--panel-w); }
  .list { font-size:13px; max-height:240px; overflow:auto; border:1px dashed #ddd; padding:8px; border-radius:8px; }
  .hint { color:#666; font-size:12px; }
  .swal2-popup { font-size:12px !important; width:auto !important; min-width:360px !important; }
  .swal2-input, .swal2-select { font-size:12px !important; height:28px !important; }

  .node-row { display:grid; grid-template-columns: 54px 1fr 1fr 28px; gap:6px; align-items:center; }
  .node-row > .badge { justify-self:start; font-weight:600; color:#334155; }
  .node-row input[type="number"]{ width:100%; height:28px; padding:0 6px; border-radius:6px; }
  .node-row button { height:28px; padding:0 8px; }

  #stressPanelBlock { display:none; }
  #stressPanel { width:100%; height:260px; position:static; border:1px solid #ccc; border-radius:8px; }
</style>
</head>

<body>
  <h2>FRAME COLLAPSE (Incremental)</h2>

  <div class="controls split" id="rowTop">
    <button id="btnDraw"   class="primary">Draw Members</button>
    <button id="btnSelect" class="ghost">Select/Edit</button>
    <button id="viewGeom" class="ghost">Geometry</button>
    <button id="btnUndo"  class="ghost">Undo</button>
    <button id="btnClear" class="ghost">Clear</button>
    <span class="hint" style="margin-left:6px;">
      Double-click member to set Yield (Fy) & ShapeF.
    </span>
  </div>

  <div class="row">
    <div class="col">
      <div id="wrap">
        <canvas id="base"    width="700" height="560"></canvas>
        <canvas id="overlay" width="700" height="560"></canvas>
      </div>

      <div class="controls split" style="margin-top:10px; gap:12px;">
        <button class="ghost labelbtn" disabled>Seg Divs</button>
        <input id="divCount"  type="number" min="1" max="50" value="10" style="width:60px;">

        <button id="btnSolve" class="primary">Solve Static</button>
        <button id="btnCollapse" class="action">Run Collapse Analysis</button>

        <div style="width:1px; height:24px; background:#ccc; margin:0 4px;"></div>

        <button id="btnAnimate" class="ghost">Animate</button>
        <button id="viewStressPanel" class="ghost">Stresses</button>

        <button class="ghost labelbtn" disabled>Def Scale</button>
        <input id="defScale"  type="number" step="any" value="1" style="width:60px;">

        <button id="btnResetView" class="ghost">Reset</button>
      </div>
    </div>

    <div class="col panel stack">
      <div>
        <div><strong>Units (display only)</strong></div>
        <div class="controls">
          <button id="btnUS" class="ghost">US (in, lbs, psi)</button>
          <button id="btnSI" class="ghost">SI (m, N, Pa)</button>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong>Nodes</strong>
            <span class="hint">Edit X/Y</span>
          </div>
          <div id="nodeList" class="list"></div>
        </div>

        <div class="panel-half">
          <div><strong>Members</strong></div>
          <div id="memberList" class="list"></div>
        </div>
      </div>

      <div class="panel-row">
        <div class="panel-half">
          <div><strong>Analysis Log</strong></div>
          <div id="resultList" class="list"></div>
        </div>

        <div class="panel-half">
          <div id="stressPanelBlock">
            <div class="controls" style="justify-content:space-between; align-items:center;">
              <strong>Stress Panel</strong>
              <div style="display:flex;align-items:center;gap:6px;">
                <label class="ghost labelbtn" disabled>Plot</label>
                <select id="stressPlotMode" style="height:26px;padding:0 6px;">
                  <option value="sigma">σ (top / bottom)</option>
                  <option value="N">N (axial)</option>
                  <option value="M">M (moment)</option>
                </select>
                <button id="btnCloseStressPanel" class="ghost">Close</button>
              </div>
            </div>
            <canvas id="stressPanel"></canvas>
            <div id="stressPanelHint" class="hint" style="margin-top:6px;">
              <div id="stressSummary" class="list" style="margin-top:6px;"></div>
              Click member to plot.
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

<script>
// ===== Global Constants & State =====
const base = document.getElementById('base');
const overlay = document.getElementById('overlay');
const stressCanvas = document.getElementById('stressPanel');
const stressBlock  = document.getElementById('stressPanelBlock');
const ctx = base.getContext('2d');
const ovr = overlay.getContext('2d');
const spx = stressCanvas.getContext('2d');

const nodeList   = document.getElementById('nodeList');
const memberList = document.getElementById('memberList');
const resultList = document.getElementById('resultList');
const stressSummary = document.getElementById('stressSummary');
const stressPlotModeSelect = document.getElementById('stressPlotMode');

const MAX_MEMBERS = 50;
let mode = 'draw';        
let viewMode = 'geom';    
let units = 'US';         

let nodes = [];
let members = [];
let nextNodeId = 1, nextMemberId = 1;

let dragStart = null, hoverEndNodeId = null;
let lastSolution = null; 
let collapseHistory = null; 

let selectedMemberId = null;
let selectedNodeId = null;
let selectedMemberForDelete = null;
let movingNodeId = null;
let moveOffset = {dx:0, dy:0};

let anim = { on:false, t0:0, raf:null };

// View Camera
const view = { scale: 1, offsetX: 0, offsetY: 0, userAdjusted: false };
const MIN_SCALE = 0.2;
const MAX_SCALE = 5;
let isPanning = false;
const panStart = { sx: 0, sy: 0, offsetX: 0, offsetY: 0 };

// ============================================
// === MATH & SOLVER FUNCTIONS (DEFINED FIRST) ===
// ============================================

function zeros(n,m){ 
    const A=Array(n); for(let i=0;i<n;i++) if(m) A[i]=Array(m).fill(0); else A[i]=0; return A; 
}

function matPick(A,r,c){ 
    const M=r.length,N=c.length,O=Array(M); 
    for(let i=0;i<M;i++){ O[i]=Array(N); for(let j=0;j<N;j++)O[i][j]=A[r[i]][c[j]]; } 
    return O; 
}

function vecPick(v,r){ return r.map(i=>v[i]); }

function mulMatVec(M, v){
    const n = M.length; const out = new Array(n).fill(0);
    for (let i = 0; i < n; i++){ let sum = 0; const row = M[i]; for (let j = 0; j < row.length; j++) sum += row[j] * v[j]; out[i] = sum; }
    return out;
}

function matMul(A,B){
    const r=A.length, c=B[0].length, p=B.length;
    const C=Array(r).fill(0).map(()=>Array(c).fill(0));
    for(let i=0;i<r;i++) for(let j=0;j<c;j++) for(let k=0;k<p;k++) C[i][j]+=A[i][k]*B[k][j];
    return C;
}

function transpose(A){ return A[0].map((_,c)=>A.map(r=>r[c])); }

function frameT(c,s){ 
    return [ [c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0], [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1] ]; 
}

function frameLocalStiffness(E,A,I,L){
    const k=Array(6).fill(0).map(()=>Array(6).fill(0));
    const a=E*A/L, b=12*E*I/(L*L*L), c=6*E*I/(L*L), d=4*E*I/L, e=2*E*I/L;
    k[0][0]=a; k[0][3]=-a; k[3][3]=a; k[3][0]=-a;
    k[1][1]=b; k[1][2]=c; k[1][4]=-b; k[1][5]=c;
    k[2][1]=c; k[2][2]=d; k[2][4]=-c; k[2][5]=e;
    k[4][1]=-b; k[4][2]=-c; k[4][4]=b; k[4][5]=-c;
    k[5][1]=c; k[5][2]=e; k[5][4]=-c; k[5][5]=d;
    return k;
}

function matMul6TKT(k,T){ 
    const KT=matMul(k,T); const TT=transpose(T); return matMul(TT,KT); 
}

function addToGlobalVar(K, ke, map){ 
    for (let r=0;r<map.length;r++){ const R=map[r]; for (let c=0;c<map.length;c++){ const C=map[c]; K[R][C] += ke[r][c]; }}
}

function getAnalysisIdForPrimary(pid, anodes){ 
    for (const [aid,obj] of Object.entries(anodes)){ if (obj.primary===pid) return parseInt(aid,10); } return null; 
}

const yUp = y => base.height - y;

// --- BUILD MODEL ---
function buildAnalysisModelFrame(modifiers = null){
    const anodes = {};
    const dofMap = { primary:{}, analysis:{} };
    let aNextId = 1;
    for (const n of nodes){
        const id = aNextId++;
        anodes[id] = { x_up: n.x, y_up: yUp(n.y), primary: n.id };
        const base = (id - 1) * 3;
        dofMap.primary[n.id] = base;
        dofMap.analysis[id]  = base;
    }
    const nA = Object.keys(anodes).length;
    const N  = nA * 3;
    const K  = zeros(N, N);
    const F  = zeros(N);
    const geom = {};

    for (const m of members){
        const ni = getAnalysisIdForPrimary(m.n1, anodes);
        const nj = getAnalysisIdForPrimary(m.n2, anodes);
        if (!ni || !nj) continue;
        const pi = anodes[ni], pj = anodes[nj];
        const dx = pj.x_up - pi.x_up, dy = pj.y_up - pi.y_up;
        const L  = Math.hypot(dx, dy);
        if (L < 1e-9) continue;
        const c = dx / L, s = dy / L;
        
        let E = m.E || 0, A = m.A || 0, I = m.I || 0;
        
        if(modifiers && modifiers[m.id]){
            E *= modifiers[m.id].E_fac;
            A *= modifiers[m.id].A_fac;
            I *= modifiers[m.id].I_fac;
        }

        if (!(E > 0 && A > 0 && I > 0)) continue;
        const kLoc = frameLocalStiffness(E, A, I, L);
        const T    = frameT(c, s);
        const kG   = matMul6TKT(kLoc, T);
        const baseI = dofMap.analysis[ni], baseJ = dofMap.analysis[nj];
        const map   = [baseI, baseI+1, baseI+2, baseJ, baseJ+1, baseJ+2];
        addToGlobalVar(K, kG, map);
        geom[m.id] = { i: ni, j: nj, L, c, s, T };
    }
    return { N, dofMap, anodes, K, F, geom };
}

function computeInternalEndForces(build, U){
    const { dofMap, geom } = build;
    const internal = {};
    for (const memIdStr of Object.keys(geom)){
        const memId = parseInt(memIdStr, 10);
        const gEl   = geom[memId];
        if (!gEl) continue;
        const m = memberById(memId);
        if (!m) continue;
        const E=m.E, A=m.A, I=m.I;
        const bi = dofMap.analysis[gEl.i];
        const bj = dofMap.analysis[gEl.j];
        const ue = [ U[bi], U[bi+1], U[bi+2], U[bj], U[bj+1], U[bj+2] ];
        const u_loc = mulMatVec(gEl.T, ue);
        const kLoc = frameLocalStiffness(E, A, I, gEl.L);
        const f_loc = mulMatVec(kLoc, u_loc); 
        internal[memId] = { Ni: f_loc[0], Vi: f_loc[1], Mi: f_loc[2], Nj: f_loc[3], Vj: f_loc[4], Mj: f_loc[5] };
    }
    return internal;
}

function generateSublines(build, U, divCount){
    const sublines = [];
    const { dofMap } = build; 
    for (const m of members){
        const niID = m.n1, njID = m.n2;
        const bi = dofMap.primary[niID], bj = dofMap.primary[njID];
        if(bi===undefined || bj===undefined) continue;
        const nodeI = nodeById(niID), nodeJ = nodeById(njID);
        const ui = { u: U[bi+0], v: U[bi+1] }, uj = { u: U[bj+0], v: U[bj+1] };
        const poly = [];
        for (let k=0; k<=divCount; k++){
            const t=k/divCount;
            const x_up = nodeI.x + t*(nodeJ.x-nodeI.x);
            const y_up = yUp(nodeI.y + t*(nodeJ.y-nodeI.y)); 
            poly.push({ x_up, y_up, u: ui.u*(1-t)+uj.u*t, v: ui.v*(1-t)+uj.v*t });
        }
        sublines.push(poly);
    }
    return sublines;
}

// --- SOLVER KERNEL ---
function solveFrameInternal(stiffMod = null){
    const build = buildAnalysisModelFrame(stiffMod);
    const { N, dofMap, K, F, geom } = build;
    
    for (const n of nodes){
        const base = dofMap.primary[n.id];
        if (base === undefined) continue;
        F[base+0] += n.Fx || 0; F[base+1] += n.Fy || 0; F[base+2] += n.Mz || 0;
    }
    
    const constrained = new Set();
    for (const n of nodes){
        const base = dofMap.primary[n.id];
        if (base === undefined) continue;
        if (n.bc === 'fixed'){ constrained.add(base+0); constrained.add(base+1); constrained.add(base+2); }
        else if (n.bc === 'simple'){ constrained.add(base+0); constrained.add(base+1); }
        else if (n.bc === 'rollerX'){ constrained.add(base+0); }
        else if (n.bc === 'rollerY'){ constrained.add(base+1); }
    }
    
    const allIdx = [...Array(N).keys()];
    const freeIdx = allIdx.filter(i => !constrained.has(i));
    if (freeIdx.length === 0) return null; 

    const Kff = matPick(K, freeIdx, freeIdx);
    const Ff  = vecPick(F, freeIdx);
    
    let Uf;
    try { Uf = numeric.solve(Kff, Ff); } catch { return null; }
    if(Uf.some(x=>!isFinite(x))) return null;
    
    const U = Array(N).fill(0);
    freeIdx.forEach((gi, k) => { U[gi] = Uf[k]; });

    const internal = computeInternalEndForces(build, U);
    
    const stress = {};
    const stressSummary = {};
    for (const m of members){
        const gEl = geom[m.id];
        const int = internal[m.id];
        if (!gEl || !int) continue;
        const L = gEl.L;
        const xs=[], Ns=[], Ms=[], sigTop=[], sigBot=[];
        let NabsMax=0, MabsMax=0;
        for(let k=0; k<=10; k++){ 
            const t=k/10; 
            const N_val = int.Ni*(1-t) + int.Nj*t;
            const M_val = int.Mi*(1-t) + int.Mj*t;
            xs.push(L*t); Ns.push(N_val); Ms.push(M_val);
            NabsMax = Math.max(NabsMax, Math.abs(N_val));
            MabsMax = Math.max(MabsMax, Math.abs(M_val));
            let sTop=0, sBot=0;
            if(m.A>0 && m.S>0){
                const sAx = N_val/m.A; const sB = M_val/m.S;
                sTop=sAx+sB; sBot=sAx-sB;
            }
            sigTop.push(sTop); sigBot.push(sBot);
        }
        stress[m.id] = { L, x:xs, N:Ns, M:Ms, sigmaTop:sigTop, sigmaBot:sigBot }; 
        stressSummary[m.id] = { NabsMax, MabsMax };
    }

    const DIV = Math.max(1, Math.min(50, (parseInt(document.getElementById('divCount').value) || 10)));
    const sublines = generateSublines(build, U, DIV);

    return { Ufull:U, dofMap, sublines, stress, stressSummary };
}

// ===== DISPLAY & INTERACTION =====

function draw(){
    ctx.clearRect(0,0,base.width,base.height);
    ovr.clearRect(0,0,overlay.width,overlay.height);
    drawGrid(ctx);
    
    ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#222'; ctx.font='12px system-ui'; ctx.fillStyle='#000';
    for (const m of members){
      const a=nodeById(m.n1), b=nodeById(m.n2);
      const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
      const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, M=worldToScreen(mx,my);
      ctx.fillText(m.label||`M${m.id}`, M.x+4, M.y-6);
    }
    ctx.restore();

    for (const n of nodes){
      const p=worldToScreen(n.x,n.y);
      ctx.save(); ctx.fillStyle='#000';
      if(n.bc==='fixed') ctx.fillRect(p.x-8,p.y-8,16,16);
      else if(n.bc==='simple'){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-6,p.y+10); ctx.lineTo(p.x+6,p.y+10); ctx.fill(); }
      ctx.fillStyle='#1d4ed8'; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#db2777'; ctx.lineWidth=2;
      if(n.Fx){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+30*(n.Fx>0?1:-1),p.y); ctx.stroke(); }
      if(n.Fy){ ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x,p.y+30*(n.Fy<0?1:-1)); ctx.stroke(); }
      ctx.restore();
      drawCoordTag(ctx, p.x+10, p.y-12, `(${n.x.toFixed(1)}, ${n.y.toFixed(1)})`);
    }
    
    if(viewMode==='def' && lastSolution && lastSolution.sublines){
        let scale = parseFloat(document.getElementById('defScale').value)||1;
        // If animation is running and provides a scale override (e.g. standard vibration) use it
        // If collapse is running, the Displacement U is absolute, so scale should be 1.0 ideally, 
        // but we respect the logic that sets lastSolution.sublines
        
        ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#e11d48';
        for(const poly of lastSolution.sublines){
            ctx.beginPath();
            for(let k=0; k<poly.length; k++){
                const p=poly[k];
                const S=worldToScreen(p.x_up + scale*p.u, yCanvas(p.y_up + scale*p.v));
                if(k===0) ctx.moveTo(S.x,S.y); else ctx.lineTo(S.x,S.y);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    drawSelection();
}

function drawGrid(g){ g.save(); g.lineWidth=1; g.strokeStyle='#eee'; const bbox=modelBounds(); g.restore(); }
function drawCoordTag(g, x, y, text){ g.save(); g.fillStyle='rgba(0,0,0,0.7)'; g.fillRect(x,y,80,16); g.fillStyle='#fff'; g.fillText(text,x+4,y+12); g.restore(); }
function drawSelection(){
    if(selectedNodeId){ const n=nodeById(selectedNodeId), p=worldToScreen(n.x,n.y); ovr.save(); ovr.lineWidth=3; ovr.strokeStyle='#10b981'; ovr.beginPath(); ovr.arc(p.x,p.y,12,0,Math.PI*2); ovr.stroke(); ovr.restore(); }
    if(selectedMemberForDelete){ const m=memberById(selectedMemberForDelete), a=nodeById(m.n1), b=nodeById(m.n2); const A=worldToScreen(a.x,a.y), B=worldToScreen(b.x,b.y); ovr.save(); ovr.lineWidth=4; ovr.strokeStyle='#f59e0b'; ovr.beginPath(); ovr.moveTo(A.x,A.y); ovr.lineTo(B.x,B.y); ovr.stroke(); ovr.restore(); }
}

function modelBounds(){
    if(nodes.length===0)return {x0:0,y0:0,w:100,h:100};
    let x0=Infinity,x1=-Infinity,y0=Infinity,y1=-Infinity;
    nodes.forEach(n=>{ x0=Math.min(x0,n.x); x1=Math.max(x1,n.x); y0=Math.min(y0,n.y); y1=Math.max(y1,n.y); });
    return {x0,y0,w:x1-x0||1,h:y1-y0||1};
}

// ===== EVENT LISTENERS =====

document.getElementById('btnDraw').onclick = () => { mode='draw'; overlay.style.cursor='crosshair'; setActiveGroup(modeBtns,'btnDraw'); draw(); };
document.getElementById('btnSelect').onclick = () => { mode='select'; overlay.style.cursor='pointer'; setActiveGroup(modeBtns,'btnSelect'); draw(); };
document.getElementById('viewGeom').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };
document.getElementById('viewDef').onclick = ()=>{ viewMode='def'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewDef'); draw(); };
document.getElementById('viewStressPanel').onclick = ()=>{ viewMode='stresspanel'; toggleStressPanel(true); setActiveGroup(viewBtns,'viewStressPanel'); draw(); };
document.getElementById('btnCloseStressPanel').onclick = ()=>{ viewMode='geom'; toggleStressPanel(false); setActiveGroup(viewBtns,'viewGeom'); draw(); };

document.getElementById('btnUndo').onclick = () => { if(nodes.length>0)nodes.pop(); refreshLists(); draw(); };
document.getElementById('btnClear').onclick = () => { nodes=[]; members=[]; nextNodeId=1; nextMemberId=1; lastSolution=null; draw(); refreshLists(); };

document.getElementById('btnSolve').onclick = () => { 
    const sol = solveFrameInternal();
    if(sol){
        lastSolution = sol; collapseHistory=null;
        resultList.innerHTML = nodes.map(n=>`<div>N${n.id}: ux=${round6(sol.Ufull[sol.dofMap.primary[n.id]])}</div>`).join('');
        draw(); Swal.fire('Solved','Static OK','success');
    } else Swal.fire('Error','Unstable','error');
};

document.getElementById('btnResetView').onclick = () => { lastSolution=null; collapseHistory=null; draw(); };

// === INCREMENTAL COLLAPSE LOGIC ===
document.getElementById('btnCollapse').onclick = () => {
    const sol0 = solveFrameInternal();
    if(!sol0){ Swal.fire('Error','Initial Solve Failed','error'); return; }

    let minLambda = Infinity, criticalReason="None", critMemId=null;
    for(const m of members){
        const res = sol0.stress[m.id], sum = sol0.stressSummary[m.id];
        const Mp = (m.shapeF||1.15)*(m.S||0)*(m.Fy||36000);
        if(Mp>0 && sum.MabsMax>1e-9){
            const lam = Mp/sum.MabsMax; if(lam<minLambda){ minLambda=lam; criticalReason="Yield"; critMemId=m.id; }
        }
        // Buckling
        const n1=nodeById(m.n1), n2=nodeById(m.n2);
        const isPinned=bc=>['simple','rollerX','rollerY'].includes(bc);
        let K=0.5; if(isPinned(n1.bc)||isPinned(n2.bc)) K=0.7; if(isPinned(n1.bc)&&isPinned(n2.bc)) K=1.0;
        const Pcr = (Math.PI**2 * m.E * m.I)/((K*res.L)**2);
        let minN=0; for(let v of res.N) if(v<minN) minN=v;
        if(Math.abs(minN)>1e-9){
            const lam=Pcr/Math.abs(minN); if(lam<minLambda){ minLambda=lam; criticalReason="Buckling"; critMemId=m.id; }
        }
    }

    if(minLambda===Infinity || minLambda>1e6){ Swal.fire('Info','No critical limit found','info'); return; }

    // Init History
    collapseHistory = [];
    collapseHistory.push({ U:new Array(sol0.Ufull.length).fill(0), lambda:0 });
    const U_crit = sol0.Ufull.map(v=>v*minLambda);
    collapseHistory.push({ U:U_crit, lambda:minLambda });

    let currentTotalU = [...U_crit];
    let stiffMod = {}; members.forEach(m=>stiffMod[m.id]={I_fac:1, E_fac:1, A_fac:1});
    let currentLambda = minLambda;
    const STEPS=2, INC_PCT=0.1;
    let logHtml = `<div>Critical λ=${minLambda.toFixed(3)} (${criticalReason} M${critMemId})</div>`;

    for(let step=1; step<=STEPS; step++){
        // Check yield/buckle based on currentTotalU
        const build0 = buildAnalysisModelFrame(); 
        const internal = computeInternalEndForces(build0, currentTotalU);
        let fails=[];
        for(const m of members){
            const int=internal[m.id];
            const M_max = Math.max(Math.abs(int.Mi), Math.abs(int.Mj));
            const N_min = Math.min(int.Ni, int.Nj);
            const Mp = (m.shapeF||1.15)*(m.S||0)*(m.Fy||36000);
            
            const n1=nodeById(m.n1), n2=nodeById(m.n2);
            const isPinned=bc=>['simple','rollerX','rollerY'].includes(bc);
            let K=0.5; if(isPinned(n1.bc)||isPinned(n2.bc)) K=0.7; if(isPinned(n1.bc)&&isPinned(n2.bc)) K=1.0;
            const Pcr = (Math.PI**2 * m.E * m.I)/((K*build0.geom[m.id].L)**2);

            if(M_max>=Mp && stiffMod[m.id].I_fac>0.1) { stiffMod[m.id].I_fac=0.01; fails.push(`M${m.id} Yield`); }
            if(Math.abs(Math.min(0,N_min))>=Pcr && stiffMod[m.id].A_fac>0.1) { stiffMod[m.id].A_fac=0.05; stiffMod[m.id].E_fac=0.05; fails.push(`M${m.id} Buckle`); }
        }
        if(fails.length>0) logHtml+=`<div style="color:red;font-size:11px;">Step ${step}: ${fails.join(',')}</div>`;

        const solInc = solveFrameInternal(stiffMod);
        if(!solInc) break;
        const scaleFact = INC_PCT * minLambda;
        const deltaU = solInc.Ufull.map(u=>u*scaleFact);
        currentTotalU = currentTotalU.map((v,k)=>v+deltaU[k]);
        currentLambda += scaleFact;
        collapseHistory.push({ U:[...currentTotalU], lambda:currentLambda });
    }

    resultList.innerHTML = logHtml + `<div style="color:green">Analysis Done. Press Animate.</div>`;
    
    // Show final state
    viewMode='def'; setActiveGroup(viewBtns,'viewDef');
    const buildF = buildAnalysisModelFrame();
    const finalSub = generateSublines(buildF, currentTotalU, 10);
    lastSolution = { Ufull:currentTotalU, sublines:finalSub, stress:{}, stressSummary:{} };
    document.getElementById('defScale').value=1;
    draw();
};

document.getElementById('btnAnimate').onclick = () => {
    if(anim.on){ anim.on=false; draw(); return; }
    anim.on=true; anim.t0=0;
    const dur = 5000;
    const tick = (ts) => {
        if(!anim.on) return;
        if(!anim.t0) anim.t0=ts;
        if(collapseHistory && collapseHistory.length>1){
            // Collapse Animation
            const prog = ((ts-anim.t0)%dur)/dur;
            const idx = prog*(collapseHistory.length-1);
            const iA=Math.floor(idx), iB=Math.min(collapseHistory.length-1, iA+1);
            const t = idx-iA;
            const UA=collapseHistory[iA].U, UB=collapseHistory[iB].U;
            const Ucurr = UA.map((v,k)=>v*(1-t)+UB[k]*t);
            const b = buildAnalysisModelFrame();
            lastSolution = { sublines:generateSublines(b, Ucurr, 10), Ufull:Ucurr };
            draw(1);
            const lam = collapseHistory[iA].lambda*(1-t) + collapseHistory[iB].lambda*t;
            ctx.save(); ctx.fillStyle='black'; ctx.font='bold 14px sans-serif'; ctx.fillText(`Load Factor: ${lam.toFixed(3)}`, 10, 20); ctx.restore();
        } else {
            // Static Vibration
            const t=(ts-anim.t0)/1000;
            const base=parseFloat(document.getElementById('defScale').value)||1;
            draw(base * 0.5*(1-Math.cos(2*Math.PI*t)));
        }
        requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
};

// Overlay Helpers
overlay.addEventListener('contextmenu', e=>e.preventDefault());
overlay.addEventListener('mousedown', e=>{
    const {x,y} = mousePos(e);
    if(mode==='draw'){
        const nid=nearNodeId(x,y); let sn;
        if(nid) sn=nodeById(nid); else { const id=addNode(x,y); sn=nodeById(id); }
        dragStart={x:sn.x, y:sn.y, nodeId:sn.id};
    } else if(mode==='select'){
        const nid=nearNodeId(x,y,8);
        if(nid) { selectedNodeId=nid; movingNodeId=nid; moveOffset={dx:x-nodeById(nid).x, dy:y-nodeById(nid).y}; }
        else { const mid=nearMemberId(x,y,6); if(mid) { selectedMemberForDelete=mid; if(viewMode==='stresspanel') {selectedMemberId=mid; plotStressPanel();} } } 
    }
    draw();
});
overlay.addEventListener('mousemove', e=>{
    const {x,y} = mousePos(e);
    if(mode==='draw' && dragStart){
        draw(); const p0=worldToScreen(dragStart.x,dragStart.y), p1=worldToScreen(x,y);
        ovr.save(); ovr.lineWidth=2; ovr.setLineDash([5,5]); ovr.strokeStyle='blue'; ovr.beginPath(); ovr.moveTo(p0.x,p0.y); ovr.lineTo(p1.x,p1.y); ovr.stroke(); ovr.restore();
    }
    if(mode==='select' && movingNodeId){
        const n=nodeById(movingNodeId); n.x=x-moveOffset.dx; n.y=y-moveOffset.dy; lastSolution=null; draw();
    }
});
overlay.addEventListener('mouseup', e=>{
    const {x,y}=mousePos(e);
    if(mode==='draw' && dragStart){
        const nid=nearNodeId(x,y); let en;
        if(nid) en=nodeById(nid); else { const id=addNode(x,y); en=nodeById(id); }
        if(en.id!==dragStart.nodeId) addMember(dragStart.nodeId, en.id);
        dragStart=null; draw(); refreshLists();
    }
    if(mode==='select') movingNodeId=null;
});
overlay.addEventListener('dblclick', e=>{
    const {x,y}=mousePos(e);
    const mid=nearMemberId(x,y,6); if(mid) editMember(memberById(mid));
    const nid=nearNodeId(x,y,8); if(nid) editNode(nodeById(nid));
});
overlay.addEventListener('wheel', e=>{
    e.preventDefault(); const d=e.deltaY<0?1.1:0.9; view.scale*=d; draw();
},{passive:false});

function mousePos(e){ const r=overlay.getBoundingClientRect(); return { x:(e.clientX-r.left-view.offsetX)/view.scale, y:(e.clientY-r.top-view.offsetY)/view.scale }; }
function round6(x){ return Math.round(x*1e6)/1e6; }
function refreshLists(){ 
    nodeList.innerHTML=nodes.map(n=>`<div>N${n.id}</div>`).join(''); 
    memberList.innerHTML=members.map(m=>`<div>M${m.id}</div>`).join(''); 
}
function autoFitIfNeeded(){ if(!view.userAdjusted && nodes.length>0) { /* simplified autofit */ } }

// Start
refreshLists(); draw();

})();
</script>
</body>
</html>
